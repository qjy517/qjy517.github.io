[{"content":"复习总的运算符重载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; //全部运算符的重载 class Person { public: string *m_name; int m_age; //构造函数 Person(int age,string name) { m_age=age; m_name=new string (name); } //默认构造函数 Person():m_age(0),m_name(nullptr){} //因为类中有指针，要有拷贝构造函数进行深拷贝 Person(const Person\u0026amp;p) { this-\u0026gt;m_age=p.m_age; this-\u0026gt;m_name=new string (*(p.m_name)); } //析构函数 ~Person() { if (this-\u0026gt;m_name!=nullptr) { delete this-\u0026gt;m_name; this-\u0026gt;m_name=nullptr; } } //赋值重载 Person\u0026amp;operator=(const Person \u0026amp;p) { this-\u0026gt;m_age=p.m_age; this-\u0026gt;m_name=new string (*(p.m_name));//深拷贝 return *this; } }; //+的重载 //返回类型不是引用，因为要返回的时临时变量 Person operator+(const Person \u0026amp;p1,const Person \u0026amp;p2) { Person p; p.m_age=p1.m_age+p2.m_age; p.m_name=new string (*(p1.m_name)+*(p2.m_name)); return p; } //\u0026gt;\u0026gt;的 重载 //返回的是引用，便于链式使用，流只能是引用传递 istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;is,Person \u0026amp;p) { string str; cin\u0026gt;\u0026gt;p.m_age\u0026gt;\u0026gt;str; p.m_name=new string (str); return is; } //\u0026lt;\u0026lt;的重载 ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,Person p) { os\u0026lt;\u0026lt;p.m_age\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;*(p.m_name); return os; } //前置++ Person \u0026amp;operator++(Person \u0026amp;p) { p.m_age++; return p; } //赋值重载在类内 //后置++ Person operator++(Person \u0026amp;p,int) { Person temp; //要提前写出=的重载 temp=p; p.m_age++; return temp; } //==的重载 bool operator==(const Person \u0026amp;p1,const Person \u0026amp;p2) { return (p1.m_age==p2.m_age\u0026amp;\u0026amp;*(p1.m_name)==*(p2.m_name)); } //！=的重载 bool operator!=(const Person \u0026amp;p1,const Person \u0026amp;p2) { return (p1.m_age!=p2.m_age||*(p1.m_name)!=*(p2.m_name)); } void test01() { Person p; Person temp(14,\u0026#34;mike\u0026#34;); p=temp; cout\u0026lt;\u0026lt;p\u0026lt;\u0026lt;endl; } void test02() { Person p1(13,\u0026#34;Amy\u0026#34;); Person p2(12,\u0026#34;Mike\u0026#34;); Person p3=p1+p2; cout\u0026lt;\u0026lt;p3\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;p1+p2\u0026lt;\u0026lt;endl; } void test03() { Person p; cin\u0026gt;\u0026gt;p; cout\u0026lt;\u0026lt;p\u0026lt;\u0026lt;endl; } int main() { test01(); test02(); test03(); return 0; } ","date":"2025-09-01T23:03:56+08:00","permalink":"https://qjy517.github.io/p/%E5%A4%8D%E4%B9%A0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","title":"复习运算符重载"},{"content":"通讯录管理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;limits\u0026gt; # define Max 100 using namespace std; class Person { //理解构造函数 private: string name; string phone; string address; int age; int sex; public: void set_infor(); void get_infor(); void revise(); string get_name(); };//冒号 class Person_book { public: vector\u0026lt;Person\u0026gt; address_book; void add_person(); void delete_person(); void clear(); void find_person(); void look_address_book(); void revise_person(); }; void show_maneu(); int main() { Person_book book; int sec; while (true) { show_maneu(); if (!(cin \u0026gt;\u0026gt; sec)) { cin.clear(); // 清除错误状态 // 忽略缓冲区中剩余的字符 cin.ignore(numeric_limits\u0026lt;streamsize\u0026gt;::max(), \u0026#39;\\n\u0026#39;); cout \u0026lt;\u0026lt; \u0026#34;输入错误，请输入数字(0-6)\u0026#34; \u0026lt;\u0026lt; endl; continue; } switch (sec) { case 1: { book.add_person();break; } case 2: { book.delete_person();break; } case 3: { book.find_person();break; } case 4: { book.look_address_book();break; } case 5: { book.revise_person();break; } case 6: { book.clear();break; } case 0: { cout \u0026lt;\u0026lt; \u0026#34;欢迎下次使用\u0026#34; \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } default: { break; } } } } //类外定义函数的格式 void Person::set_infor() { cout \u0026lt;\u0026lt; \u0026#34;输入姓名：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; name; cout \u0026lt;\u0026lt; \u0026#34;输入性别\u0026#34; \u0026lt;\u0026lt; endl; int a; while (true) { cin \u0026gt;\u0026gt; a; if (a == 0 || a == 1) { sex = a; break; } cout \u0026lt;\u0026lt; \u0026#34;输入有误，重新输入\u0026#34; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;输入年龄:\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; age; cout \u0026lt;\u0026lt; \u0026#34;输入地址：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; address; cout \u0026lt;\u0026lt; \u0026#34;输入电话：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; phone; } void Person::get_infor() { if (sex == 1) { cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; \u0026#34;男\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; phone \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; address \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; \u0026#34;女\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; phone \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; address \u0026lt;\u0026lt; endl; } } void Person::revise() { cout \u0026lt;\u0026lt; \u0026#34;输入新姓名：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; name; cout \u0026lt;\u0026lt; \u0026#34;输入新性别\u0026#34; \u0026lt;\u0026lt; endl; int a; while (true) { cin \u0026gt;\u0026gt; a; if (a == 0 || a == 1) { sex = a; break; } cout \u0026lt;\u0026lt; \u0026#34;输入有误，重新输入\u0026#34; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;输入新年龄:\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; age; cout \u0026lt;\u0026lt; \u0026#34;输入新地址:\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; address; cout \u0026lt;\u0026lt; \u0026#34;输入新电话:\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; phone; } string Person::get_name() { return name; } void Person_book::add_person() { Person temp; if (address_book.size() == Max) { cout \u0026lt;\u0026lt; \u0026#34;通讯录满了\u0026#34; \u0026lt;\u0026lt; endl; return; } temp.set_infor(); address_book.push_back(temp); cout \u0026lt;\u0026lt; \u0026#34;添加成功\u0026#34; \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); system(\u0026#34;cls\u0026#34;); } void Person_book::delete_person() { if (address_book.size() == 0) { cout \u0026lt;\u0026lt; \u0026#34;通讯录为空无法删除\u0026#34; \u0026lt;\u0026lt; endl; return; } string target; cout \u0026lt;\u0026lt; \u0026#34;输入目标联系人:\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; target; auto it = find_if(address_book.begin(), address_book.end(), [\u0026amp;target](Person\u0026amp; p) { return p.get_name() == target; }); if (it == address_book.end()) { cout \u0026lt;\u0026lt; \u0026#34;没有找到联系人\u0026#34; \u0026lt;\u0026lt; endl; return; } address_book.erase(it); cout \u0026lt;\u0026lt; \u0026#34;删除成功\u0026#34; \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); system(\u0026#34;cls\u0026#34;); } void Person_book::find_person() { string target; if (address_book.size() == 0) { cout \u0026lt;\u0026lt; \u0026#34;通讯录为空无法查找\u0026#34; \u0026lt;\u0026lt; endl; return; } cout \u0026lt;\u0026lt; \u0026#34;输入目标联系人:\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; target; auto it = find_if(address_book.begin(), address_book.end(), [\u0026amp;target](Person\u0026amp; p) { return p.get_name() == target; }); if (it == address_book.end()) { cout \u0026lt;\u0026lt; \u0026#34;没有找到联系人\u0026#34; \u0026lt;\u0026lt; endl; return; } (*it).get_infor(); system(\u0026#34;pause\u0026#34;); system(\u0026#34;cls\u0026#34;); } void Person_book::clear() { address_book.clear(); cout \u0026lt;\u0026lt; \u0026#34;删除成功\u0026#34; \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); system(\u0026#34;cls\u0026#34;); } void Person_book::look_address_book() { if (address_book.size() == 0) { cout \u0026lt;\u0026lt; \u0026#34;通讯录为空\u0026#34; \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); system(\u0026#34;cls\u0026#34;); return; } for (auto i : address_book) { i.get_infor(); } system(\u0026#34;pause\u0026#34;); system(\u0026#34;cls\u0026#34;); } void Person_book::revise_person() { string target; if (address_book.size() == 0) { cout \u0026lt;\u0026lt; \u0026#34;通讯录为空,无法修改\u0026#34; \u0026lt;\u0026lt; endl; return; } cout \u0026lt;\u0026lt; \u0026#34;输入目标联系人：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; target; auto it = find_if(address_book.begin(), address_book.end(), [\u0026amp;target](Person\u0026amp; p) { return p.get_name() == target; }); (*it).revise(); cout \u0026lt;\u0026lt; \u0026#34;修改成功\u0026#34; \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); system(\u0026#34;cls\u0026#34;); } void show_maneu() { cout \u0026lt;\u0026lt; \u0026#34;1.添加联系人\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;2.删除联系人\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;3.查找联系人\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;4.查看全部联系人\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;5.修改联系人\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;6.清空联系人\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;0.退出通讯簿\u0026#34; \u0026lt;\u0026lt; endl; } 复盘错点：\n类的声明要加分号，struct和class区别在于没有显示未public和private的成员是什么类型的。 理解继承：本题只是要对Person对象进行管理，并不是要直接使用Personn中的函数或成员。 迭代器合法化考虑，在本题中，所有解迭代器的操作中，我们要考虑迭代是否合法，是否指向一个未定义的空间 每个操作完成后要提醒使用者 操作是否完成 system的pause和cls用法，一个是要键入一个值在往下运行，一个是清屏操作 理解成员函数应该什么位置，题中Person类的数据成员，就要有对应的函数来修改他们，并且是不需要提供参数的，因为，内部成员函数可以直接调用成员（this指针) 理解新算法find_if（b,e,[\u0026amp;目标元素的成员]（元素类型\u0026amp;p），它用来 查找给定容器中元素的成员，即容器中元素是类类型。 成员函数在类外定义的格式 ","date":"2025-09-01T12:46:25+08:00","permalink":"https://qjy517.github.io/p/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","title":"通讯录管理系统"},{"content":"运算符的重载 +的重载 原因：普通+只适用于内置类型，我们想要实现类的加减\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include \u0026lt;iostream\u0026gt; using namespace std; class Person { public: int A_m; int B_m; //基于成员函数的加号重载 /* Person\u0026amp; operator+(const Person\u0026amp;p) { Person temp; temp.A_m=this-\u0026gt;A_m+p.A_m; temp.B_m=this-\u0026gt;B_m+p.B_m; return temp; } */ //不能写Person的引用，因为你返回的是局部变量temp，用完就销毁了，所以会导致引用的非法访问； //以后要写返回值是引用的函数，要明白返回的是不是局部变量· /* Person operator+(const Person\u0026amp;p) { Person temp; temp.A_m=this-\u0026gt;A_m+p.A_m; temp.B_m=this-\u0026gt;B_m+p.B_m; return temp; } */ }; //基于全局函数实现+运算的重载 Person operator+(const Person\u0026amp;p1,const Person \u0026amp;p2) { Person temp; temp.A_m=p1.A_m+p2.A_m; temp.B_m=p1.B_m+p2.B_m; return temp; } void test01() { Person p1,p2; p1.A_m=1; p1.B_m=2; p2.A_m=3; p2.B_m=4; //Person p3=p1+p2//报错，因为编译器识别这个加号，要用到加号的重载，可以基于成员函数，或是全局函数 Person p3=p1+p2; cout\u0026lt;\u0026lt;p3.A_m\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;p3.B_m\u0026lt;\u0026lt;endl; } //一个Person加上一个int：在定义一个+的重载 /* Person operator+ (Person \u0026amp;p,int \u0026amp;a) { Person temp; temp.A_m=p.A_m+a; temp.B_m=p.B_m; return temp; } */ Person operator+ (Person \u0026amp;p,int a) { Person temp; temp.A_m=p.A_m+a; temp.B_m=p.B_m; return temp; } //对于这两个接受int的重载函数，前者引用，则只接受一个对象，即p3=p+(int)a,而p3=p+10会报错，后者两者都行因为是拷贝赋值 //所以保留后者 void test02() { Person p,p1; p1.A_m=10; p1.B_m=1; int a=10; p=p1+10;//编译器不清楚+是怎么加的； p=p1+a; } int main() { test01(); test02(); return 0; } 总结：\n注意声明形式 注意接受的是引用还是普通类型，参数的位置是不变的 在哪声明重载都可以 注意返回类型，是拷贝不是引用 +只能有两个参数 \u0026raquo;的重载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; using namespace std; //想要用左移运算符来一下输出类的内容 //要用到\u0026lt;\u0026lt;的重载 class Person { friend ostream\u0026amp;operator\u0026lt;\u0026lt;(ostream\u0026amp;os,Person \u0026amp;p); public: Person(int a,int b) { x=a; y=b; } int get_x() { return x; } int get_y() { return y; } //成员函数重载 //不知道返回什么，就用void，编译器会自动根据返回值，写出类型 //void operator\u0026lt;\u0026lt;(ostream \u0026amp; os);//类似p.operatro\u0026lt;\u0026lt;(os)即p\u0026lt;\u0026lt;os,显然不符合cout\u0026lt;\u0026lt;p,所以\u0026lt;\u0026lt;的重载不使用成员函数 private: int x; int y; }; //类似+重载，想到两种方式：成员函数重载，全局函数重载 //全局函数重载 /* void 不对 void operator\u0026lt;\u0026lt;(ostream \u0026amp;os,Person \u0026amp;p)//为什么要用引用，因为输入输出流对象不能够使用拷贝构造函数，只能引用 //os\u0026lt;\u0026lt;p { os\u0026lt;\u0026lt;p.get_x()\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;p.get_y()\u0026lt;\u0026lt;endl; } */ ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os,Person \u0026amp;p)//为什么要用引用，因为输入输出流对象不能够使用拷贝构造函数，只能引用 //os\u0026lt;\u0026lt;p { //os\u0026lt;\u0026lt;p.get_x()\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;p.get_y()\u0026lt;\u0026lt;endl; os\u0026lt;\u0026lt;p.x\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;p.y\u0026lt;\u0026lt;endl;//声明友元不需要get return os; } void test01() { Person p(1,0); //cout\u0026lt;\u0026lt;p;//错误，\u0026lt;\u0026lt;运算符无法识别p类型； cout\u0026lt;\u0026lt;p;//重载后，发现可以使用了 } void test02() { Person p1(2,0); Person p2(3,0); cout\u0026lt;\u0026lt;p1\u0026lt;\u0026lt;p2\u0026lt;\u0026lt;endl;//连续输出发现报错，原因在于链式运算，第一次\u0026lt;\u0026lt;返回void，则第二次\u0026lt;\u0026lt;相当于\u0026lt;\u0026lt;(void,p2),肯定不对,修改返回类型 } //如果我想要不使用get_x,get_y来定义\u0026lt;\u0026lt;重载可使用友元 int main() { test01(); test02(); return 0; } 总结：\n只能用全局函数重载，注意位置 注意返回类型，以及链式输出的影响 注意流对象使用引用以及复习友元 这里使用引用，便不能输出临时值如cout\u0026laquo;p1-p2\u0026laquo;endl; ++的重载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;iostream\u0026gt; using namespace std; //想要对类对象实现++操作，有前置和后置的区别 class My_int { friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os,My_int \u0026amp;p); public: //前置 //一开始不知道返回什么，用void /* 后面有原因更改返回类型 void operator++ () { a++; b++; return *this; } */ My_int\u0026amp; operator++ () { a++; b++; return *this; } //后置 My_int operator++(int)//占位操作符，用来区分重载函数，编译器，认为带int的版本就是后置 { My_int temp(*this); a++;b++; return temp;//重要：这里返回的是局部变量，所以返回类型就不是引用，而是拷贝 } My_int(My_int \u0026amp;p) { a=p.a; b=p.b; } My_int()=default; private: int a=2; int b=3; }; ostream\u0026amp; operator\u0026lt;\u0026lt; (ostream \u0026amp;os,My_int \u0026amp;p) { //声明为友元函数 os\u0026lt;\u0026lt;p.a\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;p.b\u0026lt;\u0026lt;endl;//加上这个endl会输出两个换行符 return os; } void test01() { My_int p; cout\u0026lt;\u0026lt;++p\u0026lt;\u0026lt;endl;//写\u0026lt;\u0026lt;重载,发现写完++,\u0026lt;\u0026lt;的重载后还是错的，原因是++返回的是void，变成cout\u0026lt;\u0026lt;void\u0026lt;\u0026lt;endl;所以要改变返回值 //改为My_int,还要是引用，因为想要对他操作，而不是它的拷贝 } int main() { test01(); return 0; } 总结：\n后置与前置的区别 后置使占位参数 后置返回的是类的拷贝，不能对同一对象连续操作 前置返回的是引用，可以连续操作 返回类型是由\u0026laquo;重载函数的参数决定的 只在成员函数中定义声明 注意返回局部变量时，返回类型不能使用引用，如后置 前三章总结 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #include \u0026lt;iostream\u0026gt; using namespace std; class Person { friend Person operator-(const Person \u0026amp;p1,const Person \u0026amp;p2); friend Person operator- (const Person \u0026amp;p1,int a); friend istream \u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is,Person \u0026amp;p); //friend ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os,Person \u0026amp;p);Perons \u0026amp;p,与Person p不能共存，因为编译器区分不了 friend ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp;os,Person p); public: Person(int a,int b) { age=a; height=b; } //前置： Person \u0026amp;operator--() { age--; height--; return *this; } //后置： Person operator--(int) { Person temp(*this); age--; height--; return temp; } Person()=default; private: int age; int height; }; Person operator- (const Person \u0026amp;p1,const Person \u0026amp;p2) { Person p3; p3.age=p1.age-p2.age; p3.height=p1.height-p2.height; return p3; } Person operator- (const Person \u0026amp;p1,int a) { Person p3; p3.age=p1.age-a; p3.height=p1.height; return p3; } istream \u0026amp; operator\u0026gt;\u0026gt;(istream \u0026amp;is,Person \u0026amp;p) { is\u0026gt;\u0026gt;p.age\u0026gt;\u0026gt;p.height; return is; } /* ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;os,Person \u0026amp;p) { os\u0026lt;\u0026lt;p.age\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;p.height; return os; } */ //适配输出类临时值而非对象的重载 ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os,Person p) { os\u0026lt;\u0026lt;p.age\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;p.height; return os; } void test01() { Person p1(1,2); Person p2(2,3); cout\u0026lt;\u0026lt;p1-p2\u0026lt;\u0026lt;endl;//这里使用p1-p2会报错，这是因为p1-p2是一个临时值，他不能赋给Person \u0026amp;，引用只能是对象，不能是值，所以，可以在写一个函数 //但是两个不能同时存在，要区分好 } void test02() { Person p1; cin\u0026gt;\u0026gt;p1; cout\u0026lt;\u0026lt;p1\u0026lt;\u0026lt;endl; } void test03() { Person p(4,3); cout\u0026lt;\u0026lt;p--\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;--p\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;p\u0026lt;\u0026lt;endl; } int main() { //test01(); //test02(); test03(); return 0; } 总结：\n参数数目是有规定的 一定要关注临时值的问题，就是不能传给一个临时值给引用，先比较而言，比如\u0026laquo;,不更改参数的值，使用拷贝传递更好，因为cout\u0026laquo;p1-p2\u0026laquo;endl;不会报错，而使用引用会，因为p1-p2是一个临时值，不是对象 赋值运算符(=)的重载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;iostream\u0026gt; using namespace std; class Person { public: int *m_age;// Person (int age) { m_age=new int(age); } Person (Person \u0026amp;p) { m_age=new int(*p.m_age); //这时不需要判断m_age是否指向为空，因为这时拷贝构造函数，是初始化的过程，初始化时，指针是为空的 } ~Person() { if (m_age!=nullptr) { delete m_age; m_age=nullptr;//释放后要为空，防止指向未知的内存 } } //重载赋值运算符 //先返回void，后面会说明，正确 /* void operator=(Person \u0026amp;p) { //如果m_age有指向堆区的内存，则先释放在分配新的内存 if (m_age!=nullptr) { delete m_age; m_age=nullptr; } //相当于一个深拷贝操作 m_age=new int(*p.m_age); }\\ */ Person \u0026amp; operator=(Person \u0026amp;p) { //如果m_age有指向堆区的内存，则先释放在分配新的内存 if (m_age!=nullptr) { delete m_age; m_age=nullptr; } //相当于一个深拷贝操作 m_age=new int(*p.m_age); } }; void test01() { Person p1(10); Person p2(18);//这时报错是因为默认的拷贝构造函数时浅拷贝，这会还与赋值运算无关 p2=p1;//此时会报错，因为编译器对于赋值运算符默认执行的是浅拷贝，还记得在拷贝构造函数中，深拷贝和浅拷贝的区别吗 //p1与p2指向同一个内存，当调用析构函数释放内存时，会释放两次导致，第二次释放非法访问 //所以要重构赋值运算符，在成员函数中重载 cout\u0026lt;\u0026lt;*p1.m_age\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;*p2.m_age\u0026lt;\u0026lt;endl; //要明白，赋值运算也是可以链式使用的，这表明，返回类型不能是void,这样会导致使用=时参数为void而不是Person \u0026amp; //所以返回类型是Person \u0026amp;； } int main() { test01(); return 0; } 总结：\n可以再外部也可以在类内 注意初始化和赋值的区别，他们调用函数不同，初始化调用拷贝构造函数，但是他们都是关于深拷贝浅拷贝的问题因为有指针 关系运算符（==，！=） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Person { friend bool operator==(Person \u0026amp;p1,Person\u0026amp;p2); friend bool operator!=(Person \u0026amp;p1,Person\u0026amp;p2); public: string name; int age; Person(string n,int a) { name=n; age=a; } }; //在类外，返回的是bool类型,在类外记得声明友元 bool operator==(Person \u0026amp;p1,Person \u0026amp;p2) { return (p1.age==p2.age\u0026amp;\u0026amp;p1.name==p2.name); } bool operator!=(Person \u0026amp;p1,Person \u0026amp;p2) { return (p1.age!=p2.age||p1.name!=p2.name); } void test01() { Person p1(\u0026#34;Tom\u0026#34;,11); Person p2(\u0026#34;To\u0026#34;,11); if (p1==p2)//这时报错，因为编译器无法识别，可以再类内也可以在类外定义 { cout\u0026lt;\u0026lt;\u0026#34;p1与p2等\u0026#34;\u0026lt;\u0026lt;endl; } if (p1!=p2) { cout\u0026lt;\u0026lt;\u0026#34;p1!=p2\u0026#34;\u0026lt;\u0026lt;endl; } } int main() { test01(); return 0; } 总结：\n返回类型 函数调用运算符()的重载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Add { public: int a; int b; //重载函数调用运算符，也就是()的重载，他就是一个仿函数，因为()本身不是函数，但却实现类似函数的功能 //他比较灵活，可以接受任意一个参数，可以返回任何值 int operator()(int x,int y) { return x+y; } }; void test() { Add a1; int sum=a1(1,2); cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; //a1本身是一个对象，通过()的重载能实现类似函数的功能，所以被称为仿函数 //匿名函数对象，就是创建一个临时值来调用仿函数，用完即释放内存 cout\u0026lt;\u0026lt;Add()(2,3)\u0026lt;\u0026lt;endl; } int main() { test(); return 0; } 总结：\n仿函数 仿函数的灵活性 理解匿名函数对象，与匿名对象 ","date":"2025-09-01T12:46:00+08:00","permalink":"https://qjy517.github.io/p/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/","title":"重载运算符"},{"content":"深拷贝和浅拷贝 浅拷贝知识将值原封不动的复制到对象当中，其中指针的指向也是相同的一块地方，这就导致另一个问题，就是如果我要释放掉这块地方，那摸另个指针再次释放时就会造成非法访问\n每个类中都有默认构造函数和默认拷贝构造函数，当我们不显示写出时，编译器就会调用这些函数，来初始化对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Person { public: int age; int *height; Person()=default;//默认构造函数 Person(int a) { cout\u0026lt;\u0026lt;\u0026#34;调用有参构造函数\u0026#34;\u0026lt;\u0026lt;endl; height=new int(a);//分配一块存储int的内存，为a，height指向这块内存 } ~Person() { delete height; } } int main() { Person p1(10); Person p2(p1);//调用默认拷贝构造函数，p1.height和p2.height指向同一块内存 cout\u0026lt;\u0026lt;*p1.height\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;*p2.height\u0026lt;\u0026lt;endl; } 这段程序会报错，原因在于在执行完程序后，编译器调用析构函数释放堆的内存，释放掉p1.height指向的内存后，在释放p2.height指向的内存，但是他们指的是同一块地方，已经被释放的地方就不能再次访问，所以第二次调用析构函数会报错\n解决：既然默认拷贝构造函数只是值得传递，那么我们就声明一个新的拷贝构造函数，不是值得简单传递，而是为对象开辟一个新的空间\n1 2 3 4 5 6 7 8 9 10 11 12 //旧的拷贝构造函数 Person (const Person a) { age=p.age; height=a.height//只是值传递 } //新的拷贝构造函数 Person (const Person a) { age=p.age height =new int (*a.height); } 使用场景：类中涉及到指针时\n","date":"2025-09-01T12:45:29+08:00","permalink":"https://qjy517.github.io/p/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/","title":"深拷贝与浅拷贝"},{"content":"额外的string操作 string的额外操作参数大多都是下标\nsubstr操作 s.substr(pos,n):返回一个string了，包含从s中pos处开始的n个元素的拷贝\n我们也可以使用string（b，e）来获取子串的拷贝\n适用于想要得到字符串中某个子串的场景，注意使用的是下标\n基于下标的改变string的函数 对应的练习\n将字符串中的thr替换为through\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; void Func(string \u0026amp;s,const string \u0026amp;oldval,const string \u0026amp;newval); int main() { string str; cin\u0026gt;\u0026gt;str; Func(str,\u0026#34;tho\u0026#34;,\u0026#34;though\u0026#34;); cout\u0026lt;\u0026lt;str\u0026lt;\u0026lt;endl; return 0; } //首先想找到对应的字符串，用循环加上string对象的创建来查找 void Func(string \u0026amp;s,const string \u0026amp;oldval,const string \u0026amp;newval) { auto curr=s.begin(); //插入删除操作记得要更新迭代器，这里要用\u0026lt;=而不是！因为用！时，最后的一串字符串就无法比较，因为到指向第一个时就break了 while (curr!=(s.end()-oldval.size())) { //用迭代器来创建于与要查找字符串相同数量的拷贝，比较是否相同，然后删除，插入(返回插入元素的迭代器，更新 if(string (curr,curr+oldval.size())==oldval) { curr=s.erase(curr,curr+oldval.size()); curr=s.insert(curr,newval.begin(),newval.end()); curr+=newval.size(); } else { curr++; } } } string 的搜索操作 要注意的是，如果我们想要搜索字符串，就选find\n对与first和last，是有条件的搜索，比如s.find_first_of(string c),意思是找到c中的任意字符出现的位置，并返回下标，注意是字符，不是找到字符串\n返回的是下标，常用size_t来保存\n练习题：\n#include #include #include using namespace std;\n//关键在于理解，注意是单词，那么我每次读取文件中一个单词，然后最长的单词比较，再决定改变最长的单词\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;fstream\u0026gt; using namespace std; // void Func(const string \u0026amp;s,string \u0026amp;longest); int main() { //复习文件流的知识 fstream file(\u0026#34;test.txt\u0026#34;,ios::out); if(!file.is_open()) { cout\u0026lt;\u0026lt;\u0026#34;file open error\u0026#34;\u0026lt;\u0026lt;endl; return -1; } string str; while (getline(cin,str)) { if(str.empty()) { break; } file\u0026lt;\u0026lt;str\u0026lt;\u0026lt;endl; } //不要忘关文件 file.close(); file.open(\u0026#34;test.txt\u0026#34;,ios::in);//注意ios string curr,longest; while (file\u0026gt;\u0026gt;curr) { Func(curr,longest); } cout\u0026lt;\u0026lt;longest\u0026lt;\u0026lt;endl; return 0; } void Func(const string \u0026amp;s,string \u0026amp;longest) { size_t pos=0; string digits{\u0026#34;dfpg\u0026#34;}; if((pos=s.find_first_of(digits,pos))==string::npos)//注意string::npos { longest=s.size()\u0026gt;longest.size()?s:longest; } } ","date":"2025-09-01T12:42:42+08:00","permalink":"https://qjy517.github.io/p/%E9%A2%9D%E5%A4%96%E7%9A%84string%E6%93%8D%E4%BD%9C/","title":"额外的string操作"},{"content":"首先容器适配器就是依据我们想要的功能来设计的特殊的容器。\n容器适配器（Container Adapters）是 C++ 标准库中的一类特殊容器，它们对现有的容器（如 std::vector、std::deque、std::list）进行包装，提供了特定的接口和行为，以满足特定的数据处理需求。C++ 标准库提供了三种主要的容器适配器：std::stack（栈）、std::queue（队列）和 std::priority_queue（优先队列）。\n所有适配器都通用的操作 栈（stack） 他定义在头文件中中，后进先出\n操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; int main() { stack\u0026lt;int\u0026gt; intStack;//空栈 for(int i=1;i\u0026lt;=5;i++) { intStack.push(i); } int value=intStack.top(); cout\u0026lt;\u0026lt;value\u0026lt;\u0026lt;endl; intStack.pop(); value=intStack.top(); cout\u0026lt;\u0026lt;value\u0026lt;\u0026lt;endl; return 0; } 队列（queue） ","date":"2025-09-01T12:42:15+08:00","permalink":"https://qjy517.github.io/p/%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8%E7%AE%80%E4%BB%8B/","title":"容器适配器简介"},{"content":"管理容器容量的函数 首先我们要明白容器元素数量和容器容量是有差别的，通常来说，每插入一个元素，都会自动扩大容器的容量\nc.shrink_to_fit():将c的容量缩小至c的size()大小 c.capacity()：返回c可以保存元素的数量，包括已将保存的元素数量 c.reserve(n)：分配至少n个元素的容量，注意至少 ","date":"2025-09-01T12:41:12+08:00","permalink":"https://qjy517.github.io/p/%E7%AE%A1%E7%90%86%E5%AE%B9%E5%99%A8%E5%AE%B9%E9%87%8F/","title":"管理容器容量"},{"content":"静态成员变量和函数 静态成员变量 注意：\n静态成员变量，所有对象均可访问，就是所有对象共用一块内存区域 编译时就会为静态成员变量来访问了 静态成员变量类内声明，类外初始化且必须初始化 访问静态成员变量：\n利用对象访问 利用类的作用域访问 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; using namespace std; class Person { public: static string name;//类内定义 }; string Person::name=\u0026#34;张三\u0026#34;;//类外初始化，注意格式，一定要初始化 void test01() { Person p1; cout\u0026lt;\u0026lt;p1.name\u0026lt;\u0026lt;endl;//利用对象访问 cout\u0026lt;\u0026lt;Person::name\u0026lt;\u0026lt;endl;//利用类作用域访问 } 静态成员函数 注意：\n同样所有对象都可以访问 可以在类中生声明定义，也可以在外部定义 只能访问静态成员变量，不能访问普通成员变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; using namespace std; class Person { public: static string name;//类内定义 int age; static void func(); }; string Person::name=\u0026#34;张三\u0026#34;;//类外初始化，注意格式，一定要初始化 void Person ::func() { name=\u0026#34;李四\u0026#34;;//可以访问静态成员变量 //age=10;//不可以访问非静态成员变量，这样想，所有Person类对象都共享func函数，当我们调用func时，是不清楚是那个对象调用的 //而普通成员变量需要对象来访问，既然都不知道对象，所以便不能访问普通变量 } void test01() { Person p1; cout\u0026lt;\u0026lt;p1.name\u0026lt;\u0026lt;endl;//利用对象访问 cout\u0026lt;\u0026lt;Person::name\u0026lt;\u0026lt;endl;//利用类作用域访问 } void test02() { Person p1; p1.func();//对象访问 Person::func();//类作用域访问 } ","date":"2025-09-01T12:40:36+08:00","permalink":"https://qjy517.github.io/p/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/","title":"静态成员变量和函数"},{"content":"继承 继承语法和继承权限问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; using namespace std; class Base { public: int m_a; Base(int x,int y,int z) { m_a=x; m_b=y; m_c=z; } protected: int m_b; private: int m_c; }; class Son:public Base//继承的语法规则 { int m_d; void test() { m_a=19; m_b=12; //m_c=14;//public继承Base类，相当于原样继承，也就是在Base中，成员权限不变，还是public，protected，private，所以 //m_c仍然无法直接访问 //protected继承，则除基类中，除了private，其他变为protected //private继承,则基类中成员全为private } }; 总结：\n继承语法规则：一个：，两个：：是作用域 继承权限问题 继承同名成员与静态成员 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; using namespace std; //关于继承同名数据成员如何区分访问子类还是父类成员的问题 //使用作用域运算符访问 class Base { public: int m_a; Base() { m_a=19; } }; class Son:public Base { public: int m_a; }; void test() { Son temp; cout\u0026lt;\u0026lt;\u0026#34;这是Son下的m_a:\u0026#34;\u0026lt;\u0026lt;temp.m_a\u0026lt;\u0026lt;endl;//如果访问的是子类的同名数据成员，直接使用点运算符就可以访问 cout\u0026lt;\u0026lt;\u0026#34;这是Base下的m_a\u0026#34;\u0026lt;\u0026lt;temp.Base::m_a\u0026lt;\u0026lt;endl; //如果访问的是父类中的同名数据成员，就要使用点运算符和作用域共同操作 } //关于继承父类中同名静态成员的操作 //回忆有关静态成员：1.所有对象共用 2. 类内定义，类外初始化 3.可以用对象访问，也可以使用作用域访问 class Base1 { public: static int m_a; }; int Base1:: m_a=10;//类内定义，类外初始化 class Son1:public Base1 { public: static int m_a; }; int Son1::m_a=1; void test02() { Son1 temp; cout\u0026lt;\u0026lt;\u0026#34;Son下的\u0026#34;\u0026lt;\u0026lt;temp.m_a\u0026lt;\u0026lt;endl;//子类直接用点运算符访问 cout\u0026lt;\u0026lt;\u0026#34;Base下的\u0026#34;\u0026lt;\u0026lt;temp.Base1::m_a\u0026lt;\u0026lt;endl;//父类用.和：：访问 cout\u0026lt;\u0026lt;\u0026#34;Son下的\u0026#34;\u0026lt;\u0026lt;Son1::m_a\u0026lt;\u0026lt;endl;//使用作用域 cout\u0026lt;\u0026lt;\u0026#34;Base下的\u0026#34;\u0026lt;\u0026lt;Son1::Base1::m_a\u0026lt;\u0026lt;endl; } 总结：\n用作用域运算符来区分不同的成员 可以使用作用域运算符来访问静成员变量 示例视频 多态\n","date":"2025-09-01T12:39:58+08:00","permalink":"https://qjy517.github.io/p/%E7%BB%A7%E6%89%BF/","title":"继承"},{"content":"顺序容器操作总结 容器基本概况 vector：可变数组，动态存储，能够随机访问，尾后插入元素，但是中间插入元素效率不高\nstring：元素类型为char的vector，其他类似\ndeque：双端队列，前后插入可以，能够随机访问，但是中间插入元素效率不高\nlist：双端链表，不能随机访问，但插入效率高\nforw_list：单向链表，其他类似\n通用操作 构造函数 分为拷贝构造和迭代器构造\n形式：C c(c1), C c(b,e) C c{a,b,c}\n赋值和swap c1=c2，swap（a，b）\n主要最好使用泛型的swap，定义在utility头文件中，参数可以是int或者是容器\n大小 c.size c.max_size() c.empty()\n获取迭代器 c.begin, c.end()\n详细解释容器操作 初始化容器 注意array初始化要限定大小，并且与内置数组相比，可以赋值拷贝\n分为拷贝初始化和迭代器初始化\nC c1(c2)\nC c1=c2\nC c1{a,b,,c}\nC c(b,e),迭代器初始化\n迭代器初始化可以忽略容器类型的不同，前提是元素类型可以转换\n赋值和swap 重点是assign\nc.assign(b,e):将c中的元素替换为b，e迭代器之间的元素。\nc.assign(il):列表赋值\nc.assign(n,t)：替换为n个元素t\n统一使用非成员版本的swap\n向容器添加元素 所有标准库容器（除了array）都能动态添加删除元素\nc.push_front(t)\nc.emplace_front(args)\n在c的头部创建值为t或有args创建的元素，返回void\nc.push_back(t)\nc.emplace_back(args)\n返回void\nc.insert(p,t)\nc.emplace(p,args)\n在迭代器p指向的元素之前创建值为t或由args创建的元素，返回指向新添加元素的迭代器\nc.insert(p,b,e)\n将b，e之间的元素插入到p指向元素之前，返回指向新添加的第一个元素的迭代器\n访问元素 每个容器都有front成员函数，除了forwa_list外都有back成员函数\n访问成员函数都返回的是引用\nat和下标只适用于随机访问的容器\nc.back(),返回尾元素的引用\nc.front()\nc[n]\nc.at[n]：可以降低下标越界的风险\n注意：返回的是引用，我们使用auto是不会自动识别\u0026amp;，所以要显示的加上\u0026amp;\nauto \u0026amp;j=c.front()\nauto j=c.front(),不会改变c的值\n注意：调用front，back访问容器，一定要检查容器是否为空(c.empty())*\n删除元素 不适用array，因为会改变数组大小\nforw_list 有特殊的erase并且不支持pop_back,vector，string，不支持pop_front()\nc.pop_back()：返回void c.pop_front()：返回void c.erase(p)：删除p指向元素，返回被删元素的下一个元素的迭代器 c.erase(b,e）:删除b，e之间的元素，不包括e c.clear():删除所有元素 注意删除元素前要检查元素是否存在\n特殊的forward_list操作 见上一页\n关于迭代器失效问题 原因：在每次插入，删除操作后，容器内部元素的存储空间重新分配，导致迭代器，指针，引用失效\n所谓的管理迭代器就是更新每次循环中都更新迭代器，要注意失效的是对象，而函数的返回并未失效\n避免保存end()返回的迭代器 原理：当我们插入或删除元素后，容器中保存end()的迭代器会失效，注意不是end()函数失效\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; //管理迭代器，发现每次循环都会改变i的值，保证i的值一直有效 //不保存end返回的迭代器 int main() { vector\u0026lt;int\u0026gt; v{1,2,3,4}; auto i=v.begin(); //这里就没有保存end返回的迭代器，直接使用的end() //若改为 k=v.end(),while (i!=k)会一直循环，或者报错，因为插入元素后，k无效了 while (i!=v.end()) { if(*i%2) { i=v.insert(i,*i); i+=2; } else { i++; } } for (auto j:v) { cout\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } ","date":"2025-08-08T21:40:06+08:00","permalink":"https://qjy517.github.io/p/c-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%E5%B0%8F%E7%BB%93/","title":"C++顺序容器操作小结"},{"content":"顺序容器操作 向容器中添加元素 主要有两类：push和emplace，作用相同但是实现方式是不同的\n要分清哪些容器可执行哪种添加操作\npush类实际上是添加的是元素的拷贝\n使用insert的返回值来实现在同一位置的连续插入 原理：就是insert返回的是插入元素的迭代器，同一位置是插入后的同一位置\n1 2 3 4 5 6 7 8 list\u0026lt;int\u0026gt; l; auto lb=l.begin(); int n; while (cin\u0026gt;\u0026gt;n) { lb=l.insert(lb,n); } //相当于push_back(); 访问元素 对于那些能够随机访问的容器，我们可以通过下标访问，但是有下标越界的风险，所以有了at()成员函数，他会返回错误信息，当下标越界的时候。\n其他的：\n有front，back函数，他们返回的是容器中第一个元素和最后一个元素的引用，注意是引用，还有一个点就是，auto不能够自动识别引用运算，所以当我们使用想要得到front或是back函数的返回值时，我们要使用auto\u0026amp;，而不是auto。\n1 2 3 4 5 6 7 8 9 10 11 int main() { vectro\u0026lt;Int\u0026gt; v{1,2,3}; auto i=c.begin(); auto \u0026amp;j=c.front(); auto k=c.front(); cout\u0026lt;\u0026lt;*i\u0026lt;\u0026lt;endl;//得到v[0]，通过i可改变v的值 k=2;//不能沟通过k来改变v的值，因为k是一个拷贝过去的 j=5;// return 0; } 删除元素 根据不同容器的空间存储方式不同，所选用的删除方式也是不同的。\n//forward_list有特殊版本的erase\n//forward_list不支持pop_back, vector和string 不支持pop_front\n因为forward_list是链式存储的，删除一个元素会导致前置元素的后继发生改变，所以它的删除元素的实现有点特殊\nc.pop_back(): 删除c容器中最后一个元素，返回void\nc.pop_front()：删除第一个元素，返回void\nc.erase(p)：删除，迭代器所指的元素，并且返回删除元素的下一个元素的迭代器\nc.erase(b,e)：删除迭代器b，e之间的元素，要知道e是要删除的最后一个元素的下个元素的迭代器，同样返回的是最后删除元素的下个元素的迭代器\nc.clear()：清空所有元素\n从容器内部删除一个元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //删除容器中的奇数 int main() { vector\u0026lt;int\u0026gt; v{1,2,3}; auto i=v.begin(); while (i!=v.end()) { if (*i%2) { i=v.erase(i);//更新了i迭代器 } else { i++; } } 特殊的forward_list操作 因为存储结构不同，所以插入，和删除都有所不同\nlist.before_begin()： list.cbefore_begin()： 返回指向链表首元素之前不存在的元素的迭代器，所以不能够解引用。\nlist.insert_after(p,t)： lst.insert_after(p,n,t) lst.insert_after(p,b,e) lst.insert_after(p,il) 在迭代器p之后插入新的元素。t是对象，n表示数量，b，e表示一对范围的迭代器（不能指向自己），il表花括号列表。返回一个指向最后一个插入元素的迭代器，如果范围为空，则返回p，p不能够是尾后迭代器。\nemplacee_after(p,args)\nlst.erase_after(p)\nlst.erase_after(b,e)\n删除p指向元素之后的的元素，或删除迭代器b，e之间的元素（但不包含e）。返回一个指向被删除元素之后元素的迭代器\n注意：\n再对forward_list实时操作时，通常要有两个迭代器，分别是当前元素迭代器，和指向前驱元素迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //改写，从forward_list删除元素 int main() { foreward_list\u0026lt;int\u0026gt; lst{1,2,3,4,5}; auto curr=lst.begin(); auto pre=lst.before_begin(); while (curr!=lse.end()) { if(*curr%2) { curr=lst.erase_after(pre);//删除当前元素，参数就是这个元素的前驱 } else { pre=curr; curr++; } } return 0; } ","date":"2025-08-08T21:39:30+08:00","permalink":"https://qjy517.github.io/p/c-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/","title":"C++ 顺序容器操作"},{"content":"顺序容器 顺序容器的分类 vector：可变数组，能够快速访问，在尾插入元素还行，但是中间插入麻烦 deque：双端队列，支持快速访问，在头尾插入元素很快 list：双向链表，只能够双向顺序访问，不能够随机访问，但在中间插入元素较为方便 forward_list：单项链表，只支持单向顺序访问。同样插入元素方便 array：固定大小数组，支持快速访问元素，但不支持添加或删除元素 string：与vector类似的容器，但是存的是char，随机访问快，在尾部添加元素 总结：\narray相比较于内置数组而言更有益，后面讲解。 不知道使用什么容器时，选vector和list的公共操作，这样在后续需要更换容器，只需要修改名字即可。 要记住这几种容器的公共操作 容器操作 都能进行的\n定义在容器中的类型别名 iterator：加上容器作用域表示指定容器的迭代器类型 const_iterator：可读但不可写的迭代器类型 size_type：无符号整数，常用来表示容器元素下标 difference_type:带符号整数，常来用来表示两个迭代器之间的距离。 value_type：统一获取容器中的元素类型 reference：与vallue_type\u0026amp;含义相同 const_reference：与const value_type\u0026amp;含义相同 构造函数（初始化容器元素） 大写字母表示容器类型\nC c，默认构造函数，构造空容器\nC c1(c2)，拷贝c2到c1\nC c1=c2,类似\nC c(b,e)：将c初始化为迭代器b，e包围的元素\nC c{a,b,c,\u0026hellip;..}，列表初始化\n赋值和swap c1=c2\nc1={a,b,c\u0026hellip;..}\nswap(a,b):交换a，b的元素\nassign函数\n大小 c.size()：c中元素的数目 c.max_size()：c本身所容纳的最大元素数量\nc.empty()：c中没有元素返回true\n添加删除元素（不使用array） 注：不同容器接口不同\nc.insert()\nc.emplace()\nc.erase()\nc.clear()：删除c中所有元素返回void\n获取迭代器 c.begin()\nc.end()\n使用迭代器 最重要的就是使用迭代器范围来确定将要使用的元素范围\n还可以检查容器是否为空，检查begin==end\nbegin和end成员 当我们定义一个iterator时，要注意如果我们定义的不是const iterator就不要使用cbegin来初始化iterator对象\n最重要的是，通常我们用begin和end来初始化时，最好使用auto，避免繁琐也可以避免上述错误。\n容器的定义和初始化 要注意拷贝构造函数，要求两个容器类型相同，且保存的元素类型也相同\n但是如果我们使用迭代器范围进行拷贝时，如果保存的元素类型可以默认转换，那么就可以忽略容器类型\n列表初始化，使用char*时要用const\n标准库array array的大小也是类型的一部分\n比如：array\u0026lt;int,10\u0026gt;,不能够对内置数组进行拷贝和赋值的操作，但是可以对array进行拷贝和赋值操作，这是array的优点，但是要确保元素类型相同，且个数相同\n赋值和swap函数 注意区别赋值和初始化，认为赋值没有什么用\n统一使用非成员版本的swap，比较好\n非成员版本的 swap 函数定义在 \u0026lt;utility\u0026gt; 头文件中，它的参数范围比较广，可以是两个内置类型(int ),也可以是两个容器，或是两个类（关于类可以查阅一些资料）\n","date":"2025-08-07T20:33:35+08:00","permalink":"https://qjy517.github.io/p/c-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%AE%80%E6%B4%81/","title":"C++ 顺序容器简洁"},{"content":"文件流对象 1.fstream分类 首先要知道文件流已有三种类型，分别为ifstream，ofstream，fstream。其中ifstream关联的文件·就只能进行读取操作，ofstream关联的文件就只能进行写入操作，而fstream关联的对象可以通过文件模式来显示的表明是要读取还是要写入\n2. fstream的字符读取写入 步骤：\nfstream的open函数来指定流与哪一个文件所关联。可以显示的指出是写还是读 fstream的is_open来确定是否打开了对应的文件，因为有可能打开文件错误，造成后续的操作都是违法的 fsream的put用来向流所关联的文件写入一个字符的 fstream的get是向流所关联的文件得到一个字符的，但要注意是以什么方式打开的文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; using namespace std; int main() { fstream file;//定义一个未绑定的的文件流 //文件模式out，打开指定的文件，如果文件存在就会消除原有数据在打开文件，如果没有文件就创建一个文件，不想要消除可以使用app模式 file.open(\u0026#34;test.txt\u0026#34;,ios::out); //判断是否打开成功 if (!file.is_open()) { cout\u0026lt;\u0026lt;\u0026#34;file open error\u0026#34;\u0026lt;\u0026lt;endl; return 0；//注意不要少 } //因为文件模式是out，可写，用put写单个字符 file.put(\u0026#39;c\u0026#39;); char w=\u0026#39;a\u0026#39;; file.put(w); file.close(); //重新打开文件，文件模式为in，表示读取数据 file.open(\u0026#34;test.txt\u0026#34;,ios::in); cout\u0026lt;\u0026lt;(char)file.get()\u0026lt;\u0026lt;(char)file.get()\u0026lt;\u0026lt;endl;//get也只是读取单个字符 file.close(); return 0; } 3.fstream多行读取 fstram的get重载 fstream的getline 文件读取的终结符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { fstream file; //位操作符来控制或，既读也写，并且不覆盖 file.open(\u0026#34;test.txt\u0026#34;,ios::out|ios::in|ios::app); //这一段使用get函数重载会发现str[2]没显示，这是因为get函数读取到换行符后就不在读取，就是光标仍在换行符之前，不被读取 /* char str[3][1024]={0}; if (!file.is_open()) { cout\u0026lt;\u0026lt;\u0026#34;file open error\u0026#34;\u0026lt;\u0026lt;endl; return 0; } file.get(str[0],1024); file.get(str[1],1024); file.get(str[2],1024); cout\u0026lt;\u0026lt;str[2]\u0026lt;\u0026lt;endl; */ //可以使用getline函数来读取，因为他读走了\\n，但不输出\\n，并且参数中有流参数，可以直接使用file，但归根结底还是读走 //一行string，要有个string对象来存储，所以vector vector\u0026lt;string\u0026gt; v1; string line; while (getline(file,line)) { v1.push_back(line); } for (auto i:v1) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; } //getline有俩个重载函数，第二个中第三个参数可以指定读到哪个字符终止读取 return 0; } 读取文件中全部内容 原理：就是将文件中全部字符都读到一个string对象中去，遇到文件结束符停止，要用到eof函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { fstream file; //位操作符来控制或，既读也写，并且不覆盖 file.open(\u0026#34;test.txt\u0026#34;,ios::out|ios::in|ios::app); if (!file.is_open()) { cout\u0026lt;\u0026lt;\u0026#34;file open error\u0026#34;\u0026lt;\u0026lt;endl; return 0; } string str; while (!file.eof()) { str.push_back((char)file.get()); } for (auto i:str) { cout\u0026lt;\u0026lt;i; } file.close(); return 0; } fstream读取文件大小 利用fstream的seek和tell函数来去确定文件大小\n简析seek函数\n注意是从origin处移动多少位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { fstream file; //位操作符来控制或，既读也写，并且不覆盖 file.open(\u0026#34;test.txt\u0026#34;,ios::out|ios::in|ios::app); if (!file.is_open()) { cout\u0026lt;\u0026lt;\u0026#34;file open error\u0026#34;\u0026lt;\u0026lt;endl; return 0; } //这里要确定使用seekg还是seekp file.seekg(0,ios::end); int sum=file.tellg(); cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; return 0; } 是输入流就是seekg，是输出流就是seekp，并且定位符有end，begin。\nfstream的存取文字，就是汉字不会乱码 原理：利用read和write函数来进行存取数据。\n函数原型：\nstd::istream\u0026amp; read(char* s, std::streamsize n);\nstd::ostream\u0026amp; write(const char* s, std::streamsize n);\n这里参数为指针，即字符数组，所以不能直接使用string对象，string对象有函数data(),返回的是一个指向数组的指针，所以也可以替换\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { fstream file; file.open(\u0026#34;test2.txt\u0026#34;,ios::out); if (!file.is_open()) { cout\u0026lt;\u0026lt;\u0026#34;file open error\u0026#34;\u0026lt;\u0026lt;endl; return 0; } string str{\u0026#34;使用string代替数组\u0026#34;}; file.write(str.data(),str.length()); file.close(); file.open(\u0026#34;test2.txt\u0026#34;,ios::in); char str2[100]={0}; file.read(str2,100); cout\u0026lt;\u0026lt;str2\u0026lt;\u0026lt;endl; return 0; } 总结：1. 好忘记close\n​ 2.对于存取文字还是使用数组方便一些\nfstream的重载 fstream的重载就类似cin和cout函数，直接向文件持续输入与输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { fstream file; file.open(\u0026#34;test3.txt\u0026#34;,ios::out); if (!file.is_open()) { cout\u0026lt;\u0026lt;\u0026#34;file open error\u0026#34;\u0026lt;\u0026lt;endl; return 1; } int a=666; string l{\u0026#34;今天天气好\u0026#34;}; //类似cin，cout，\u0026lt;\u0026lt;往文件里写数据，\u0026gt;\u0026gt;从文件里读数据 //使用fstream重载时，无论原数据是什么类型都转换为string存入文件中 file\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl; file\u0026lt;\u0026lt;l\u0026lt;\u0026lt;endl; file.close(); file.open(\u0026#34;test3.txt\u0026#34;,ios::in); if (!file.is_open()) { cout\u0026lt;\u0026lt;\u0026#34;file open error\u0026#34;\u0026lt;\u0026lt;endl; return 1; } //因为重载将数据全转换为string类型，所以从file中读取到666是string，存到str中 string str; file\u0026gt;\u0026gt;str; cout\u0026lt;\u0026lt;str\u0026lt;\u0026lt;endl; file.close(); return 0; } 总结 从键盘输入数据到文件中去 将数据按照一行一行读到文件中去\n遇到特殊符号停止输入，如空行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { fstream file; file.open(\u0026#34;test3.txt\u0026#34;,ios::out); if (!file.is_open()) { cout\u0026lt;\u0026lt;\u0026#34;file open error\u0026#34;\u0026lt;\u0026lt;endl; return 1; } string len; while(getline(cin,len)) { if (len.empty()) { break; } file\u0026lt;\u0026lt;len\u0026lt;\u0026lt;endl; } file.close(); return 0; } 读取指定数量的数据并写入文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { fstream file; file.open(\u0026#34;test3.txt\u0026#34;,ios::out); if (!file.is_open()) { cout\u0026lt;\u0026lt;\u0026#34;file open error\u0026#34;\u0026lt;\u0026lt;endl; return 1; } int count; cin\u0026gt;\u0026gt;count;//读取要输入数据的数量 cin.ignore();//忽略换行符 string len; for (int i=1;i\u0026lt;=count;i++) { cout\u0026lt;\u0026lt;\u0026#34;input the\u0026#34;\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; data:\u0026#34;\u0026lt;\u0026lt;endl; getline(cin,len); file\u0026lt;\u0026lt;len\u0026lt;\u0026lt;endl; } file.close(); return 0; } 一直读取直到某个特定字符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { fstream file; file.open(\u0026#34;test3.txt\u0026#34;,ios::out); if (!file.is_open()) { cout\u0026lt;\u0026lt;\u0026#34;file open error\u0026#34;\u0026lt;\u0026lt;endl; return 1; } char ch;//存储特定的字符 string len;//用来进行写到文件的string while (cin.get(ch)\u0026amp;\u0026amp;ch!=\u0026#39;#\u0026#39;) { //遇到换行符表示一行读取完整，要将这一行写到文件中 if (ch==\u0026#39;\\n\u0026#39;) { file\u0026lt;\u0026lt;len\u0026lt;\u0026lt;endl; len.clear();//写完一行后要清0 } //没有换行符，就把这个字符加到这一行字符串后面 else { len+=ch; } } //看最后读取的一行有没有数据，有就写，没有就算了 if (!len.empty) { file\u0026lt;\u0026lt;len\u0026lt;\u0026lt;endl; } file.close(); return 0; } 从文件中输出全部内容 1.使用getline函数来逐行读取并输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { fstream file; file.open(\u0026#34;test3.txt\u0026#34;,ios::out); if (!file.is_open()) { cout\u0026lt;\u0026lt;\u0026#34;file open error\u0026#34;\u0026lt;\u0026lt;endl; return 1; } string len; while (getline(file,len)) { cout\u0026lt;\u0026lt;len\u0026lt;\u0026lt;endl; } file.close(); return 0; } 2.使用 std::istreambuf_iterator 一次性读取并输出,即迭代器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iterator\u0026gt; using namespace std; int main() { fstream file; file.open(\u0026#34;test3.txt\u0026#34;,ios::in); if (!file.is_open()) { cout\u0026lt;\u0026lt;\u0026#34;file open error\u0026#34;\u0026lt;\u0026lt;endl; return 1; } // 使用 std::istreambuf_iterator 读取文件内容 istreambuf_iterator\u0026lt;char\u0026gt; begin(file),end; string content(begin,end); cout\u0026lt;\u0026lt;content\u0026lt;\u0026lt;endl; file.close(); return 0; } 3.使用read函数来读取，就是要用到中间字符数组来存储\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iterator\u0026gt; using namespace std; int main() { fstream file; file.open(\u0026#34;test3.txt\u0026#34;,ios::in); if (!file.is_open()) { cout\u0026lt;\u0026lt;\u0026#34;file open error\u0026#34;\u0026lt;\u0026lt;endl; return 1; } //确定文件大小，以便设定数组大小 file.seekg(0,ios::end); int size=file.tellg(); //一定要把光标移到头，以便读取 file.seekg(0,ios::beg); char buf[size]; //表示从file读取到buf中 file.read(buf,size); //有继承可知道，cout本来就是istream的对象，所以就是将buf写到cout中，cout就是标准输出流（屏幕） cout.write(buf,size); return 0; } ","date":"2025-08-05T20:31:37+08:00","permalink":"https://qjy517.github.io/p/c-%E6%96%87%E4%BB%B6%E6%B5%81/","title":"c++文件流"},{"content":"IO类 分类 标准io，就是从键盘读数据，在屏幕显示数据，如cin，cerr，cout 文件io（ifstream，ofstrem）从文件读写 stringio：从内存中直接读写数据 简介 其中istream，和ostream是相当于int的一个类型，用它来定义一个流对象，比如cin就是istream的一个对象\n要注意的是，io对象不能够拷贝或者赋值，所以在函数中不能够返回io对象，但可以返回它的引用。\nio对象的条件状态 有几个内置的类型表示流的一种状态，当流的状态发生改变时，其内置类型就会自动改变，当然配套的函数可以帮助我们来查询流的状态\n流的内置类型：\nstrm::iostate ,提供了表达条件状态的完整功能。 strm::badbit ,用来指出流已经崩溃 strm:: failbit 用来指出一个io操作失败了 strm:: eofbit 用来指出流已经到达了文件结束 strm::goodbit 表示流未处于错误状态，返回为0； 函数：\ns.eof() 若流s的到达文件末尾，流的eofbit置位，返回true s.fail() 若流failbit或者badbit置位，返回true s.good()若流处于有效状态，返回true s.clear() 将流s所有状态置位，最后流s处于有效状态 s.setstate(flag)，将流中对应状态改为flag，flag为iostate类型。 s.rdstate()返回流当前的状态，返回类型为strm::iostate 总结：使用good和fail是确定流总体状态的正确方法。\n管理流的状态 1 2 3 4 auto old_state=cin.rdstate();//保留cin的原状态 cin.clear();//使cin有效 process_input(cin);//使用cin cin.setstate(old_state);//将cin置于原状态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; istream \u0026amp; get(istream \u0026amp;); int main() { istream \u0026amp;is=get(cin); cout\u0026lt;\u0026lt;is.rdstate\u0026lt;\u0026lt;endl; } istream \u0026amp;get(istream \u0026amp;is) { string buf; while (is\u0026gt;\u0026gt;buf) { cout\u0026lt;\u0026lt;buf\u0026lt;\u0026lt;endl; } return is; ","date":"2025-08-05T20:30:42+08:00","permalink":"https://qjy517.github.io/p/c-%E5%88%9D%E8%AF%86io/","title":"c++初识IO"},{"content":"尽量在定义构造函数时，也要定义默认构造函数。\n定义一个类中数据成员是类类类型的默认构造函数 就是当一个类中有 没有默认构造函数的成员时，要定义该类的默认构造函数，那就需要在构造函数的初始化列表中显式的调用这个成员的有参构造函数\n1 2 3 4 5 6 7 8 9 10 11 12 class A { A (int \u0026amp;a) : dataA(a) {};//A类没有默认构造函数 int dataA; } //B类中有A类对象，想要为B类设置一个·默认构造函数，就要显示的调用A中有参构造函数 class B { B():dataB(0){}; B(int val): dataB(val){};//有参构造函数 A dataB; } 字面值常量类 就是使用constexpr关键字，用来声明常量表达式函数，和构造函数。\nconstexpr类型的介绍 constexpr关键字，编译器就会在编译过程中执行对应语句。\nconstexpr函数 作用：\n在编译时进行计算\nconstexpr 函数可以在编译时进行求值，这允许编译器在编译阶段完成一些原本需要在运行时进行的计算，从而提高程序的运行效率。\n在 C++ 中，constexpr 函数既可以在编译时求值，也可以在运行时求值，具体取决于传入的参数是否为常量表达式。下面详细解释为什么 fact 函数在传入变量 n 时仍能正常工作：\nconstexpr 函数的特性 constexpr 函数是一种特殊的函数，它被设计成可以在编译时计算结果，前提是传入的参数是常量表达式。但这并不意味着 constexpr 函数只能在编译时调用，当传入的参数不是常量表达式时，它可以像普通函数一样在运行时被调用。\n示例代码分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; // 定义 constexpr 阶乘函数 constexpr int fact(int n) { return (n \u0026lt;= 1)? 1 : n * fact(n - 1); } int main() { // 编译时计算 5 的阶乘 constexpr int compileTimeResult = fact(5); std::cout \u0026lt;\u0026lt; \u0026#34;Compile-time factorial of 5: \u0026#34; \u0026lt;\u0026lt; compileTimeResult \u0026lt;\u0026lt; std::endl; // 运行时获取用户输入并计算阶乘 int n; std::cout \u0026lt;\u0026lt; \u0026#34;Enter a number to calculate its factorial: \u0026#34;; std::cin \u0026gt;\u0026gt; n; int runtimeResult = fact(n); std::cout \u0026lt;\u0026lt; \u0026#34;Runtime factorial of \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; runtimeResult \u0026lt;\u0026lt; std::endl; return 0; } 编译时计算：在 constexpr int compileTimeResult = fact(5); 这一行中，5 是一个常量表达式，编译器会在编译阶段调用 fact 函数计算 5 的阶乘，并将结果存储在 compileTimeResult 中。 运行时计算：在 int runtimeResult = fact(n); 这一行中，n 是一个变量，它的值是在运行时通过用户输入确定的，不是常量表达式。因此，fact(n) 会在运行时被调用，计算 n 的阶乘并将结果存储在 runtimeResult 中。 总结 constexpr 函数具有灵活性，它既可以在编译时计算结果，也可以在运行时计算结果。当传入的参数是常量表达式时，编译器会尝试在编译阶段计算函数的结果；当传入的参数不是常量表达式时，函数会在运行时被调用。这种设计使得 constexpr 函数在不同的场景下都能发挥作用。\n用于数组大小和模板参数\nconstexpr 函数的返回值可以用于指定数组的大小或者作为模板参数，因为这些地方要求使用编译时常量。\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 cpp复制#include \u0026lt;iostream\u0026gt; // 定义一个 constexpr 函数，用于返回一个固定值 constexpr int getSize() { return 10; } int main() { // 使用 constexpr 函数的返回值作为数组大小 int arr[getSize()]; std::cout \u0026lt;\u0026lt; \u0026#34;Array size is: \u0026#34; \u0026lt;\u0026lt; sizeof(arr) / sizeof(arr[0]) \u0026lt;\u0026lt; std::endl; return 0; } 解释：在这个例子中，getSize 函数被声明为 constexpr，它的返回值可以用于定义数组 arr 的大小。由于 getSize 函数可以在编译时求值，因此满足数组大小必须是编译时常量的要求。\nconstexpr构造函数 支持编译时对象创建 constexpr 构造函数允许在编译时创建对象，这意味着对象的初始化可以在编译阶段完成，而不是在运行时进行。这样可以减少运行时的开销，提高程序的执行效率。在需要大量创建相同类型对象的场景中，这种编译时初始化的优势尤为明显。\n示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 cpp复制#include \u0026lt;iostream\u0026gt; // 定义一个包含 constexpr 构造函数的类 class Point { public: // constexpr 构造函数 constexpr Point(int x, int y) : x_(x), y_(y) {} // constexpr 成员函数，用于获取 x 坐标 constexpr int getX() const { return x_; } // constexpr 成员函数，用于获取 y 坐标 constexpr int getY() const { return y_; } private: int x_; int y_; }; int main() { // 在编译时创建 Point 对象 constexpr Point p(3, 4); // 编译时获取 x 坐标 constexpr int x = p.getX(); // 编译时获取 y 坐标 constexpr int y = p.getY(); std::cout \u0026lt;\u0026lt; \u0026#34;Point: (\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 解释：在上述代码中，Point 类的构造函数被声明为 constexpr，这使得我们可以在 main 函数中使用 constexpr Point p(3, 4); 在编译时创建 Point 对象。同时，对象的成员函数 getX() 和 getY() 也被声明为 constexpr，这样在编译时就可以获取对象的坐标值。\n类的静态成员 出发点：我们想要这样一个数据成员，他是无关乎类对象的，简言之，所有类对象都共用这一个数据成员，这样修改时就只用修改这一个数据成员就行，而不是修改全部对象。\n静态数据成员属于类本身，而不是类的某个具体对象。这意味着无论创建多少个该类的对象，静态数据成员都只有一份实例，被所有对象共享。和普通的类成员不同，它不依赖于对象的创建而存在。\n声明静态成员 只需要加static关键字就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Account { public: //构造函数，不要忘记默认构造函数 Account(int a,string n):amount(a),name(n) {}; Account()=default; //静态成员函数，加上static关键字，可以重构 static double rate();//查看当前利率 static void rate(double);//设定新利率 //普通接口成员函数 void set_name(string \u0026amp;); string look_name(); void set_amount(int \u0026amp;); int look_amount(); private: int amount; string name; //静态数据成员 static double interest;//interest被所有对象共享 }; 使用类的静态成员 使用作用域运算符来访问静态成员，double r=Account::rate() ,也可以使用类对象，引用指针来访问静态成员\n不过要注意的是如果静态成员在private下的话，就不能直接通过作用域来访问，这是就要用到成员函数来访问，因为成员函数可以直接访问数据成员\n1 2 3 4 Account ac1; Acccoun *ac2=\u0026amp;ac1; r=ac1.rate(); r=ac2-\u0026gt;rate(); 定义静态成员 可以再类内部定义也可以在外部，但在外部不用再写·static ，静态数据成员时要进行类外定义并初始化的，不是构造函数初始化的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026#34;test.h\u0026#34; using namespace std; //使用 int main() { Account M; Account N; double r=0; cin\u0026gt;\u0026gt;r; cout\u0026lt;\u0026lt;M.rate()\u0026lt;\u0026lt;N.rate()\u0026lt;\u0026lt;endl; Account::rate(r); cout\u0026lt;\u0026lt;M.rate()\u0026lt;\u0026lt;N.rate()\u0026lt;\u0026lt;endl; return 0; } //这是静态函数定义 double Account::rate() { return interest; } void Account:: rate(double r) { interest=r; } ","date":"2025-08-01T23:32:54+08:00","permalink":"https://qjy517.github.io/p/c-%E7%B1%BB%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0constexprstatic/","title":"c++类：默认构造函数，constexpr，static"},{"content":"类的声明 在创建类的对象之前，我们一定要先完成对类的定义。并且类成员本身不能够是类自己，但可以是指向类的一个指针。\n友元在探 类友元 我们可以将一个类整体声明为友元，这样本身的成员就是可见的，比如类A将类B声明为友元，那么对于B中的函数而言，就可以访问A的数据成员。\n但是要注意友元关系并不存在传递性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Window_mgr { using Screen_index=string :: size_type; public: void clear(Screen_index);//只是声明，因为后续要用到Screen类但是还没定义 private: vector\u0026lt;Screen\u0026gt; screens{(10,10,\u0026#39;c\u0026#39;)}; } class Screen { using pos =string:: size_type; friend class Window_mgr;//将Window_mgr声明为友元类，然后可以定义clear函数 public: Screen(pos ht,pos wd,char c): height(ht),width(wd),content(ht*wd,c); private: pos height; pos width; string content; } void Winddow_mgr:: clear(Screen_index i) { Screen \u0026amp;s=screens[i]; s.content=string (height*width,\u0026#39; \u0026#39;); } 另成员函数作为友元 另成员函数作为友元，我们要说明友元函数在哪个类中，并且要注意声明定义的顺序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Window_mgr { using Screen_index=vector\u0026lt;Screen\u0026gt;::size_type;//size_type 是vetcor中的，所以在声明Screen之前可以使用 public: void clear(Screen_index ); private: vector\u0026lt;Screen\u0026gt; screens{(10,10,\u0026#39;a\u0026#39;)}; }; class Screen { using pos=string:: size_type; friend void Window_mgr::clear(Screen_index); public: Screen (pos ht,pos wd,char c):height(ht),width(wd),content(height*width,c){} Screen()=default; pos size(); private: pos height; pos width; string content; }; void Window_mgr::clear(Screen_index i) { Screen \u0026amp;s=screens[i];//相当于新定义一个Screen对象，然后绑定screens[i]，也就相当于赋值了。 s.content=string(s.height*s.width,\u0026#39; \u0026#39;); } //类的作用域问题：当我们在函数外部定义成员函数时，其类名是隐藏的，所以定义函数名之前要加上所属的类名 //同样的返回类型如果也在类中的定义，那么也要说明这个返回类型是在类中，否则编译器无法识别 Screen::pos Screen:: size() { return height*width; } 其中，Screen类将Window_mgr中的clear作为友元函数，要先声明函数然后再定义\n友元声明和作用域 理解友元声明：在类内部进行的友元函数的声明甚至是定义，都不是真正意义上的声明，只是被赋予了一定的访问权限，如果后续要想使用该函数，就必须在外部显示声明。\n类的作用域 作用域和定义在类外部的成员 为什么定义类成员函数时要加作用域？ 答：编译器在编译时，会将类隐藏，所以如果不加类作用域，就不知道函数名属于哪一类，就不知道，函数中的成员名字是什么意思。\n名字查找与类的作用域 用于类成员声明的名字查找 1 2 3 4 5 6 7 8 9 typedef double Money; string bal; class Account { public: Money balance() { return bal;} private: Money bal; } 编译器进入类中看到money时，再此语句之间查找money，发现是double，然后，先不进行函数体的编译继续编译后面的语句，最后编译return bal，这个bal此时在类中就是Money bal而不是是string bal\n要注意就是避免成员函数参数使用类的数据成员名字，就是因为编译器查找名字的规则\n","date":"2025-08-01T23:32:24+08:00","permalink":"https://qjy517.github.io/p/c-%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%8F%8B%E5%85%83%E5%86%8D%E6%8E%A2/","title":"c++类的声明与友元再探"},{"content":"const成员函数 目的：确保我们的this指针指向的对象的只是不会改变的，也就是具有一定的只读性，并且一个const成员函数只能调用const成员函数\n形式：在参数列表后面加上const；\n初始化string对象的方式 类的其它特性 类成员再探索 我们可以再类中自定义某种类型在类中的别名，一般在类开始时就定义\n通常有多个构造函数用来满足不同情况下的初始化，但一定要有默认构造函数\n内联函数 对于一些使用频繁，并且简单的函数可以声明为内联函数，可以提高运行速度。inline关键字\n并且inline成员函应该与相应的类定义在同一个文件夹中，即一个头文件。\n重载成员函数 作用：有着相同的作用但是细节不同，比如读取光标当前字符，和读取某行某列字符。这是函数名相同就有必要，可以简化记忆。\n返回*this的成员函数 明确返回引用和返回普通类型的区别 返回类的引用，就是相当于返回调用那个函数对象自己本身，后续的操作会对自己产生影响。 返回类，就是返回一个副本，后续操作不会影响自己 1 2 3 4 5 6 7 8 Screen \u0026amp;set(char c); Screen set(char c); //使用第一个 Screen a(2,3,\u0026#39;x\u0026#39;); a.set(\u0026#39;a\u0026#39;).display(cout) a.display//两个display相同 //使用第二个 //两个dispaly不同 基于const的重载 我们知道对与const成员函数，它的this指针被指向const，如果要返回* this，* this表示一个类，所以返回类型是 const Screen\u0026amp;。\n并且常量对象只能调用const函数，非常量对象可以用常量函数，也可以用非常量函数。但最好对应，如display。\n这里diplay的实现在private中，提高了封装性，复用性。\n总结 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; using namespace std; class Person { public: int age; void func() const; void func2(); Person ()=default; Person (int n):age(n){}; }; void Person::func() const { //age=10;//常函数不能修改成员属性，但可以访问； //因为这相当于const Person *this.age=10,this指针是const的，所以不能修改 cout\u0026lt;\u0026lt;\u0026#34;调用常函数\u0026#34;\u0026lt;\u0026lt;endl; } void func2() { cout\u0026lt;\u0026lt;\u0026#34;这是func2\u0026#34;\u0026lt;\u0026lt;endl; } void test01() { Person p1; p1.func();//普通对象可以调用常函数 const Person p2(2);//定义常对象 //p2.func2();//常对象不能调用普通成员函数 } int main() { test01(); return 0; } ","date":"2025-07-30T23:13:27+08:00","permalink":"https://qjy517.github.io/p/c-%E7%B1%BB%E4%B8%ADconst-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E7%B1%BB%E7%9A%84%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7/","title":"c++类中const 成员函数和类的其它特性"},{"content":"每日一练 求取最大公约数与最小公倍数 辗转相除法，就是用较大数除以较小数，然后再用除数除以余数，再用除数除以余数，直至余数为0；\n最小公倍数就是其乘积除以最大公约数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; int Result(int a,int b); int main() { int a,int b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;\u0026#34;最大公约数是：\u0026#34;\u0026lt;\u0026lt;Result(a,b)\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;最小公倍数是：\u0026#34;\u0026lt;\u0026lt;a*b/Result(a,b)\u0026lt;\u0026lt;endl; return 0; } int Result(int a,int b) { if(b==0) { return 0; } else { return Result(b,a%b); } } 递归求aaaaa 法一：递归\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //一个函数用来求aaa，另一个函数用来求和 //求aaa int Result（int a，int n） { if (n=1) { return a; } else { return Result(a,n-1)*10+a; } } //求和 int Sum(int a,int n) { if (n==1) { return a; } else { return Sum(a,n-1)+Result(a,n); } } 法二：循环\n1 2 3 4 5 6 7 8 int sum,i,a,n; //第一个函数用来求aaa for (i=1;i\u0026lt;=n;i++) { sum+=a a=a*10; } //第二个函数用来求和 猴子吃桃问题。猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。 第二天早上又将剩下的桃子吃掉一半，又多吃一个。以后每天早上都吃了前一天剩下的一半零一个。 到第N天早上想再吃时，见只剩下一个桃子了。求第一天共摘多少桃子。\n这是逆向的推理问题，我已经推到了f(i)=f(i-1)/2-1,f（1）表示第i天剩下的数量，但是不知道这么列递归，因为之前的都是n=1作为出口，而本题目是将第n天作为出口，所以单一的一个参数是不够的，要用到两个参数，而且另一个参数要从1开始，后续根据要求第一天，所以是peach[i]=(peach[i+1]+1)×2，递归的参数时要变大的。\n所以：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; using namespace std; int Calculate(int day,int n); int main() { int n; cin\u0026gt;\u0026gt;n; cout\u0026lt;\u0026lt;Calculate(1,n)\u0026lt;\u0026lt;endl; return 0; } int Calculate(int day,int n) { if(day==n) { return 1; } else { return (Calculate(day+1,n)+1)*2; } } ","date":"2025-07-29T22:35:07+08:00","permalink":"https://qjy517.github.io/p/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%837-29/","title":"每日一练7 29"},{"content":"类的学习 类的接口就是我们对类成员的一系列操作\n定义成员函数 引入this 当我们调用类对象的成员函数时，编译器会将隐式指针指向调用成员函数的对象，这样我们就可以在函数体内直接使用成员对象。\n比如std：：string isbn() const {return bookNo};\nv1.isbn(),这里就相当于isbn（\u0026amp;v1），所以bookNo也就是v1的成员\nconst成员函数 适用于只读取而不修改成员的函数，就是在参数列表后面加上const\n在类外部定义成员函数 先写返回类型，再写作用域，然后写·函数；\n定义一个返回this对象的函数 重点是返回类型，大多都是返回引用类型，比如sales_data中的combine，类似+=，返回左值就是引用类型。\n1 2 3 4 5 6 Sales_data\u0026amp; Sales_data::combine(const Sales_data \u0026amp;rhs) { units_sold+=rhs.units_sold; return *this } v1.combine(v2); 这里units_sold是v1的，this指向v1，rhs表示v2；返回v1的引用\n","date":"2025-07-29T22:30:11+08:00","permalink":"https://qjy517.github.io/p/c-%E7%B1%BB%E5%88%9D%E8%AF%86%E5%88%AB/","title":"c++类初识别"},{"content":"continue的用法 跳过当前循环，执行下一个循环\n例如，可以用continue来筛选我们想要的输入\n1 2 3 4 5 6 7 8 string str; while (cin\u0026gt;\u0026gt;str\u0026amp;\u0026amp;!str.empty()) { if (str[0]!=\u0026#39;\\n\u0026#39;) { continue; } } 只读取以n开头的单词\n函数传引用参数 传引用参数可以改变输入对象的值，并且不用\u0026amp;，并且使用引用可以避免拷贝，只读只需要设为const就行\n在传递参数时，如果没有改变实参的要求，尽量使用常量引用，因为常量引用收纳的实参范围更加广，能后接受普通变量以及常量；\n函数如何传递一维数组 函数传递一维数组本身就是 传递指向首元素的指针\n使用标记来传递数组，适用于数组中末尾有明显不同于其他元素的元素，例如数组存放str，末尾是\\0\n1 2 3 4 5 6 7 8 9 10 void print(const char *p) { if(cp) { while(*cp)//可以利用末尾的\\0来控制访问 { cout\u0026lt;\u0026lt;*cp++\u0026lt;\u0026lt;endl; } } } 使用标准库函数,因为数组没有迭代器\n1 2 void print(cont int *beg,const int *end) print(begin(v1),end(v1)); 在函数中显示的指出数组大小，大小可以用end()-begin()计算\n同样刻意引用数组，但是有局限性，引用什么维度的数组，实参就必须维度相同\n还有可变形参的的函数 我们想要这样一类函数，它的形参的数量是可变的，这样就可以根据条件灵活使用，根据形参的类型是否相同，分为两种，我们先学相同的，即使用initializer_list类，要包含头文件（同名）\ninitializer就相当于表示某种特定类型的数组，区别就是元素是常量,无法改变\n可提供的操作 initializer_list l;表示一个int类型元素的空列表\n初始化：initilizer····l{a,b,c}\nl.size\nl.end\nl.begin\n传递值的序列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;initializer_list\u0026gt; using namespace std; int Calculate(initializer_list\u0026lt;int\u0026gt; l1); int main() { cout\u0026lt;\u0026lt;Calculate({1,2,3,4})\u0026lt;\u0026lt;endl;//调用函数传递参数的序列时，正常大括号，还要加上中括号 return 0; } int Calculate(initializer_list\u0026lt;int\u0026gt; l1) { int sum; for (auto i:l1) { sum+=i; } cout\u0026lt;\u0026lt;\u0026#34;sum is \u0026#34;\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; return sum; } 返回类型与重载函数 1.返回一个数组指针\n可以使用using来简化操作\n比如using arr=int [10]，arr *func(int i),表示返回的是一个指向数组的指针\n2.重载函数就是同名但形参列表不同\n默认实参的使用 使用默认实参只需要一开始声明一次然后就不用再重复声明\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; string Add(int i,const string\u0026amp; s1,const string\u0026amp; end=\u0026#34;s\u0026#34;); int main() { cout\u0026lt;\u0026lt;Add(1,\u0026#34;sucess\u0026#34;,\u0026#34;es\u0026#34;)\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;Add(2,\u0026#34;failure\u0026#34;)\u0026lt;\u0026lt;endl; return 0; } string Add(int i,const string\u0026amp; s1,const string\u0026amp; end) { return (i\u0026gt;1) ? s1+end:s1; } //在函数声明和定义中，只在一处指定默认值，避免代码冗余。 ","date":"2025-07-29T22:20:29+08:00","permalink":"https://qjy517.github.io/p/c-%E5%87%BD%E6%95%B0%E7%9A%84%E7%9F%A5%E8%AF%86/","title":"c++函数的知识"},{"content":"关于vector和数组的相互拷贝 不允许使用一个数组为另个数组赋初值，也不允许使用vector对象初始化数组，但是可以使用数组来初始化vector对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //将一个数组拷贝到vector对象中去 int a[]={1,2,3,4}; vector\u0026lt;int\u0026gt; v1(begin(a),end(a)); for (auto i:v1) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; } //特殊的可以将特定的数组元素拷贝到vector中 vector\u0026lt;int\u0026gt; v3(a+1,a+3);//就是将a[1]到a[3]拷贝到vector中 //将一个vector对象拷贝到数组中去 vector\u0026lt;int\u0026gt; v2={1,2,3}; int b[3]; for (int i=0;i\u0026lt;v2.size();i++) { b[i]=v2[i]; } for (auto i:b) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; } 多维数组 多维数组的初始化和读入数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //多维数组的初始化 int arr1[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};//正常初始化 int arr2[3][4]={{1},{2},{3}};//显示初始化每行的首元素，其他元素默认初始化为0； int arr3[3][4]={1,2,3,4};//只初始化第一行 //从输入流读数据到多维数组中 //两个for循环 for (size_t i=0;i!=3;i++) { for (size_t j=0;j!=4;j++) { cin\u0026gt;\u0026gt;a[i][j]; } } //运用范围for循环 for (auto \u0026amp;i:arr1) { for (auto j:i) { cin\u0026gt;\u0026gt;j; } } 在运用范围for来读取数据时，要理解他的工作机制，第一个范围for引用遍历了arr1中的每一个元素，即i就是一个含有4个元素的数组的引用，相当于int (\u0026amp;arr)[4]=arr[0]，然后j就是遍历i中的每个元素从而达到遍历所有元素的目的；\n注意：使用范围for来处理多维数组时，除了最内层，其他所有循环的控制变量都要使用引用型\n补充利用数组来读取元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //使用指针与多维数组 /* 同样数组名表示指向第一个元素的指针，但是对于二维数组而言，第一个元素是一个数组 所以 int(*p)[4]=arr1;表示p是一个指向一个含有4个整形元素的指针 p=\u0026amp;arr1[1]; */ //使用指针遍历数组,利用auto特性不用在意类型 for (auto p=arr1;p!=arr1+3;p++) { for (auto i=*p;i!=*p+4;i++) { cout\u0026lt;\u0026lt;*i\u0026lt;\u0026lt;endl; } } //利用begin和end函数简化 for (auto p=begin(arr1);p!=end(arr1);p++) { for (auto i=begin(*p);i!=end(*p);i++) { cout\u0026lt;\u0026lt;*i\u0026lt;\u0026lt;endl; } } 说明：这里arr1被隐式的转换为指向首元素的的指针，所以p指向的就是一个含有4int类的数组，然后*p解引用，此时，p解引用表示的就是一个一维数组名，而一维数组名又会被隐式的转换为指向首元素的指针，所以i就是一个\nint*类指针，他所指向的元素就是一维数组的第一个元素\n表达式与运算符 递增与递减运算符 分为后置与前置，后置运算符就是先对对象加加，但是返回值是没加之前的副本；\n而前置运算符，也是先对对象加加，但是返回的是加之后的对象；\n一般而言，我们优先使用前置而非后置\n并且对于一般的while循环要养成下面的代码风格\n1 2 3 4 5 auto pbeg=v.begin() while (pbeg!=v.end\u0026amp;\u0026amp;*pbeg!=0) { cout\u0026lt;\u0026lt;*pbeg++\u0026lt;\u0026lt;endl;//解引用优先级比++低 } 这里先对pbeg++然后在输出加之前的pbeg，更加简洁。\n条件运算符 形式：cond ? expr1:expr2;表示，如果cond是true，则返回expr1，否则返回expr2；\nstring str=(grade\u0026lt;60) ? \u0026quot;fail\u0026quot;:\u0026quot;pass\u0026quot;\n扩展嵌套条件语句\nstring str=(grade\u0026gt;90)? \u0026quot;high pass\u0026quot;:(grade\u0026lt;60) ？\u0026quot;fail\u0026quot;:\u0026quot;pass\u0026quot;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //j将奇数变为原来的二倍 vector\u0026lt;int\u0026gt; v1; int a; while (cin\u0026gt;\u0026gt;a) { v1.push_back(a); } auto p=v1.begin(); while (p!=v1.end()) { if(((*p)%2)?1:0) { (*p)*=2; } p++; } for (auto i:v1) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0 sizeof运算符 1 2 3 4 5 6 int x; sizeof(x)=4; int a[10]; int *p=a; sizeof(a)=40=4*10; sizeof(*p)=4;//表示第一个元素的位数为4； ","date":"2025-07-17T21:04:26+08:00","permalink":"https://qjy517.github.io/p/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/","title":"c++表达式与运算符"},{"content":"数组 1. 概念 数组类似vector但又有一些局限性，他必须在编译时就确定了数组的大小，也就是说声明数组时要用常量表达式；\n初始化数组时，可以用列表初始化，特别的对与char型数组，可以用字符串字面值初始化，但是要注意此时数组的大小要\u0026gt;=string.size+1;\n常用的是指针数组\n2.访问数组元素 与vector类似，数组也可以使用下标可范围for循环来遍历元素；\n同样的可以利用指针来访问特定的元素，对于数组来说，本身的数组名就是一个指向数组第一个元素的指针，对与容器来说，迭代器可以所执行的操作，指针也都可以执行；\n出现一个问题，要想指针访问全部的元素就要知道指针的边界在哪，如此我们引入了类似迭代器中begin和end函数，但是数组毕竟不是类类型，begin和end也不是他的成员函数，所以要使用begin和end函数就要以数组的地址作为参数来使用，注意要包含头文件iteator；\n1 2 3 int a[10]; int *begin=begin(a); int *end=end(a); 注意这里begin和end的参数必须是直接的数组名，不可以是一个普通指针，即使这个指针指向的是数组第一个元素\n1 2 3 int a[10]; int *p=a; int *p1=begin(p)//这是错误的，因为p只是一个普通指针 同样在传递数组名给形参时，这个形参也不能作为参数\n解决办法：既然传递的是一个指针与其传入数组名还不能够作为begin，end的参数，不如直接将数组的begin和end作为实参传递给函数，这样就直接得到了begin，和end的指针\n实例：比较两个数组是否相等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 bool Judge_val(int *a1,int *b1,int *a2,int *b2);//a表示begin，b表示end int main() { int val1[10]={1,2,3,4,5,6,8}; int val2[10]={1,2,3,4,5,6,7}; if(Judge_val(begin(val1),end(val1),begin(val2),end(val2)))//将begin和end直接传实参 { cout\u0026lt;\u0026lt;\u0026#34;the two arr equals\u0026#34;\u0026lt;\u0026lt;endl; } else { cout\u0026lt;\u0026lt;\u0026#34;the two arr are not equals\u0026#34;\u0026lt;\u0026lt;endl; } bool Judge_val(int *a1,int *b1,int *a2,int *b2) { if ((b1-a1)!=(b2-a2)) { return false; } else { for (;(a1!=b1)\u0026amp;\u0026amp;(a2!=b2);a1++,a2++) { if (*a1!=*a2) { return false; } } } } 3. 指针的运算 指针的运算也就是指向元素的改变\n要注意的是\n1 2 3 int a[4]={1,2,3,4}; int b=2 int *p=a+b;//p指向的是a[2],记住a表示0，b=2，加起来·就是原数组的下标 4.使用指针来对数组操作 利用键盘来向数组输入元素，并全部输出数组中的元素\n1 2 3 4 5 6 7 8 9 10 11 12 int a[10]; int *beg=begin(a);//直接将指针名设为begin会造成错误，显示要明显的加上括号 int *last=end(a); while(beg\u0026lt;last) { cin\u0026gt;\u0026gt;*beg; beg++; } for (auto i:a) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; } ","date":"2025-07-16T21:17:07+08:00","permalink":"https://qjy517.github.io/p/c-%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84/","title":"c++指针与数组"},{"content":"迭代器 1. 概念 迭代器就是一个提供了一种更加通用的访问容器重元素（vector和string）的方法，迭代器类型类似于指针类型，能够间接访问容器中的对象；也是解引用的操作来获取元素的值\n也就是说只要涉及到访问容器中元素的问题就都可以用迭代器\n2. 迭代器的相关知识 1.使用迭代器 1 2 vetcot\u0026lt;int\u0026gt; v1; auto i=v1.begin(); 大多数容器都会带有返回迭代器类型的的函数，如begin()和end();\n其中迭代器的类型属于 iterator，声明一个迭代器对象就是vector\u0026lt;int\u0026gt;：： iterator i 表示这是一个名为i的是vector的迭代器\n2. 迭代器运算符和类型 迭代器类似指针，都是能够解引用来改变自身\n*s s-\u0026gt;men ==,!=,++,\u0026ndash; 1 2 auto vector\u0026lt;int\u0026gt; i=v1.cbegin(); //cbegin表示迭代器对象只能够读取但不能够修改容器中的元素 3. 迭代器使用 1 2 3 4 5 6 7 8 9 10 11 12 //读入几段文字，最后输出换行符之前的文字 vector\u0026lt;string\u0026gt; v1; string str; while (getline(cin,str)) { v1.push_back(str); } //(*i).empty,可以简化，因为i是一个迭代器，可以用1-\u0026gt;empty()代替 for (auto i=v1.begin();i!=v1.end()\u0026amp;\u0026amp;!(*i).empty();i++) { cout\u0026lt;\u0026lt;*i\u0026lt;\u0026lt;endl; } 4. 迭代器注意事项 使用的迭代器中的循环不能够再改变容器中的元素的个数\n声明iterato对象时，因为每个容器中都嵌套了iteator，所以使用iteator时要用作用域解析运算符指明iteator来自哪个容器\n1 2 vector\u0026lt;int\u0026gt; iterator i=v1.begin();//错误 vector\u0026lt;int\u0026gt; :: ineatror i=v1.begin(); 在使用迭代器循环时计for循环，到末尾的条件是！=而不是\u0026lt;=\n二分查找 使用迭代器进行二分查找，时要注意这是左闭右开的查找方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;limits\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt; v1; int n; int a; cout\u0026lt;\u0026lt;\u0026#34;input data:\u0026#34;\u0026lt;\u0026lt;endl; while (cin\u0026gt;\u0026gt;n) { v1.push_back(n); } //cin作为while条件时，用文件结束符结束读取，但会造成输入流错误，从而造成后面a读不进去 cin.clear(); cin.ignore(numeric_limits\u0026lt;streamsize\u0026gt;::max(), \u0026#39;\\n\u0026#39;); cout\u0026lt;\u0026lt;\u0026#34;input the number do you want to check:\u0026#34;; cin\u0026gt;\u0026gt;a; vector\u0026lt;int\u0026gt;::iterator right,left,mid; left=v1.begin(); right=v1.end(); //要注意条件，mid的求法 while(left\u0026lt;right) { mid=left+(right-left)/2; if(a\u0026lt;*mid) { right=mid;//体现右开 } else { if(a\u0026gt;*mid) { left=mid+1;//体现左闭 } else { break; } } } if (a==*mid) { cout\u0026lt;\u0026lt;\u0026#34;find it\u0026#34;\u0026lt;\u0026lt;endl; } else { cout\u0026lt;\u0026lt;\u0026#34;not found\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } cin作为while条件时，用文件结束符结束读取，但会造成输入流错误，从而造成后面a读不进去\n1 (*(i+a/10))++;//理解优先级++优先级比*高,错误：*（i+a/10)++,表示的是迭代器先++再解引用 ","date":"2025-07-15T22:24:54+08:00","permalink":"https://qjy517.github.io/p/c-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","title":"c++迭代器与二分查找"},{"content":"string 对象可以想加，并且可与字符串字面值和字符字面值想加，但要保证每个+两侧至少一个是string对象\ncctype中的处理string中字符的函数 isalnum(c):c是字母或数字为真\nisalpha(c):c是字母为真\niscntrl(c):c是控制字符为真\nisdigit(c):c是数字为真\nisgraph(c):c不是空格但可打印时为真\nislower(c):小写字母为真\nisprint(c):c是可打印字符为真（c是空格或是其他可见字符）\nisspace(c):是空格为真\nisupper(c):大写字母为真\nispunct(c):c为标点符号为真\ntolowe(c):c是大写输出小写，否则原样输出，注意开始有返回值，而不是判断为真，并且返回值是大写的int值 可以强转\ntoupper(c):c是小写输出大写\n对于一个字符串来说，他可以加上一个字符变量 while中用cin作为条件表示输入完成时要用文件结束符，普通用cin就是回车\nvector的基本概念 vector就是一个容器，他可以存储很多相同类型的元素，理论上相当于一个射线，可以无限延长。\nvector的初始化：分为构造初始化和列表初始化\n构造初始化：\n1 2 vector \u0026lt;int\u0026gt; v1(10,1) //存储10个1元素 vector \u0026lt;int\u0026gt; v2(v1) //用v1来初始化v2 列表初始化：\n1 vector\u0026lt;int\u0026gt; v1={1,1,1,,1}; vector添加元素： 用push_back添加，不能通过下标添加，但能通过下标访问\n当我们创建一个vector对象时，这个对象要么时已经初始化好的即已经规定了现有的元素有多少个，此时若用下标来添加新的元素就会造成非法访问。\n要么是一个空vector，不包含任何元素，用pushback来添加，不通过下标添加\n总结就是：只能对确定已知的下标进行操作，可以用范围for来确保访问vector中所有元素时是合法的\nvector 类可以进行的操作 v.empty() v.size() v.push_back(t) v[n] v1=v2 可以向string比较 易错点 可以用变量来大致说明元素个数，但是会被默认初始化为0，伺候若再次用pushback压入的数据是在n个0之后\n1 2 3 4 5 6 7 8 9 10 11 12 int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; v1(n);//可以用变量来大致说明元素个数，但是会被默认初始化为0，伺候若再次用pushback压入的数据是在n个0之后 int i; //所以构造初始化但是是默认初始化为0时，要考虑0的站位，最后使用空vector，在用pushback while (cin\u0026gt;\u0026gt;i) { v1.push_back(i); } for (auto j : v1) { cout\u0026lt;\u0026lt;j\u0026lt;\u0026lt;endl; } 所以构造初始化但是是默认初始化为0时，要考虑0的站位，最后使用空vector，在用pushback\n","date":"2025-07-14T23:01:12+08:00","permalink":"https://qjy517.github.io/p/c-cctypedef%E5%92%8Cvector%E5%88%9D%E8%AF%86/","title":"c++ cctypedef和vector初识"},{"content":"cin语句在循环中的判断，判断的是cin本身，在cin读取到文件结束符或者是无效输入时会变为假，文件结束符是ctrl+z。\ncin读取一串字符时，会省略空格；注意是一串字符；\n类定义了一个类型以及预期关联的一组操作\n使用一个类不需要关心他是如何实现的，只需要知道可以执行什么操作\n属于标准库的头文件用尖括号，不属于标准库的头文件用“”。\n浮点数用double类型，算术表达式不要使用char和bool型。\n变量相加确保是同一类型。\n字符字面值\u0026rsquo;a\u0026rsquo;字符串字面值\u0026quot;a\u0026quot;.\n声明使得一个变量变另一个程序所熟知，而定义可能在别处，声明而不定义要使用extern。\n1 2 extern int i;//声明i而非定义i int j；//声明并定义j 命名规则：\n变量名要使用小写 自定义类名要用大写字母开头 多个单词要_区分 引用： 概念：引用就是为已经定义好的一个变量起一个别名，但不是简单的拷贝，而是绑定在一起，即一个引用只能绑定一个变量且不能够换绑，引用本身也不是一个对象，所以没有引用的引用。\n形式：int \u0026amp;val=a; 其中a是已经定义声明好的int型。\n用nullptr来得到空指针；指正一定要初始化\nint *p1,p2; p1是指针，p2是int变量\nconst 对象一开始就要初始化\nconst指针：\nint *const pr=\u0026amp;a pr 一直指向a的地址不能够修改，且一定要初始化 const int *pr=\u0026amp;a 不能通过pr来改变a的值，但能通过其他方式改变，pr也可改变指向 指针得值其实就是所指向变量的地址 类型别名：\n使用typedef 使用using： using si=int si是别名，注意顺序； auto类型说明符(赋值）以及decltype类型指示符（推断）\n必要时头文件也要包含其他的头文件\n初始化string对象\n拷贝初始化 string a=s1 直接初始化 string a(4,'a') 相当于string a=“aaaa”。 string对象的读取会自动忽略开头的空白（换行符，空格）知道读取到下一个空白字符为止。类似scanf，注意string也能读取文件结束符。类似读单词\ngetline（is，a）从输入流中读取行字符（包括空格），遇到换行符停止读取\nstring的比较是先比较字符，如果字符都相同那就看长度\n","date":"2025-07-13T22:13:16+08:00","permalink":"https://qjy517.github.io/p/c-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"c++基本概念"},{"content":"第一章 数据结构绪论 基本概念和术语 数据 就是可描述客观事物的符号集合，要满足两个条件\n能够输入进电脑 能够被电脑处理 数据元素 就是组成数据的，通常被当做整体处理，被称为记录\n数据项 一个数据元素可有若干个数据项组成，可以理解为数据元素为一个结构，那么数据项就是结构中的成员\n数据对象 具有相同性质或特征的数据元素的集合，比如人为一个数据对象，其中小明，小白为数据元素，因为他们都有名字，生日，年龄等数据项\n数据结构 所谓结构就是数据元素之间的一种或多种关系，元素之间可能平行也可能嵌套等\n抽象数据结构 定义 就是一个数学模型和定义在该模型的一系列操作，比如整型，在各大电子产品都有整数类型，且有对应加减操作，尽管其操作方式不同但其数学特性相同，抽象其数学特性和操作就是一个整形的抽象数据结构 再比如线性表，一切有序的数据元素的集合及其操作都可以抽象为线性表\n抽象数据类型标准格式 ADT 抽象数据类型名\nData 数据元素之间的逻辑关系的定义\nOperation 操作1 初始条件 操作结果描述 操作2 \u0026hellip;\u0026hellip;\u0026hellip;..\nendADT\n逻辑结构与物理结构 结构分为两大类：逻辑结构域物理结构\n逻辑结构 集合结构 线性结构 树形结构 图形结构 物理结构 顺序存储 链式存储 第二章 算法 定义 就是解决特定问题的步骤的描述，在计算机表示为有限个指令，每个指令表示一个或多个操作\n算法比较 比较实现求1~n项的和\n1 2 3 4 5 int i ,sum=0,n; for (i=1;i\u0026lt;=n;i++) { sum+=i; } 1 2 int sum; sum=(1+n)*n/2 //高斯公式 算法效率的度量 分为空间上的和时间上的，没有特殊说明就为时间上的\n时间复杂度方法：大O法 步骤：\n用常数1代替运行时间中的加法项 在改后的运行次数函数中，保留最高阶 最高阶系数化为1 运行时间和运行次数函数就是看for循环部分，语句执行的次数与n的关系，这也是最坏情况\n第三章 线性表 定义 就是数据元素的顺序是固定的，这里的顺序并不是特指空间上存储的连续。就是除第一个和最后一个元素外，每个元素都有且只有一个前驱元素和后继元素，注意其中每个数据元素又可以有许多数据项，此时数据元素看做结构体\n线性表的抽象数据类型 DATA 线性表\nData 在a1~an的一系列数据元素中，就是除第一个和最后一个元素外，每个元素都有且只有一个前驱元素和后继元素，数据元素之间是一对一关系。\noperation 本地链接\n线性表的顺序存储结构 是空间上的顺序存储，典型代表为数组\n数组长度与线性表长度 线性表长度是有意义的数据元素的长度，而数组长度是分配的内存总长度\n地址的计算 对于连续的数据元素a1~an loc(ai+1)=loc(ai)+c loc(ai)=loc(a1)+(i-1)*c，通过此式子，每个数据元素都能用一个式子算出来，为O(1),具有这种存储特点的为随机存储\n顺序存储结构的插入和删除 注意此时将整个表作为一个对象代码实现为\n1 2 3 4 5 6 typedef struct { int data[MAXSIZE]; int length; }List //数组已经包含在结构体中 插入操作 顺序结构存储的插入与删除要调用目标对象后面所有的数据元素进行前进后退操作 插入算法思路：\n插入位置不合理，抛出异常 线性表长度大于数组长度，抛出异常 将第i个数据元素后面的所有元素后退一位 插入元素 线性表长度加一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int ListInsert(struct *L,int i,struct e) { if (i\u0026lt;1||i\u0026gt;Maxsize) {return error} if (L-\u0026gt;length==Maxsize) {return error} if (i\u0026lt;=L-\u0026gt;length) { for (k=L-\u0026gt;length;k\u0026gt;=i;k--) { L[k]=L[k-1]; } L[i-1]=e; } } 删除操作 删除操作思路：\n删除位置判定 取出删除元素 将删除元素后的所有元素都前移一位 表长减一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //初始条件：顺序列表L已存在，i在1到L.length之间 //操作结果：删除第i个元素，并返回删除元素e的值 int ListDelete(List *L,int i,int *e) { if (i\u0026lt;1||i\u0026gt;L-\u0026gt;length) { return error; } *e=L-\u0026gt;data[i-1]; if (i\u0026lt;L-\u0026gt;length) //如果删除元素不在末尾就要移动元素 { for (k=i;k\u0026lt;L-\u0026gt;length;k++) { L-\u0026gt;data[k-1]=L-\u0026gt;data[k] } } } 线性表顺序存储结构总结 优点：可以快速取出相应的元素，只需知道其下标 缺点：不能够动态管理线性表的长度，容易造成数据溢出，或存储浪费，在插入与删除操作需要移动大量元素，为 O(n);\n线性表的链式结构 代表就是链表，能够解决插入与删除的痛点\n定义 一个链表主要有节点构成，节点的有指针域和数据域构成，，指针域用来描述两节点之间的关系，数据域用来存放数据； 这样数据对象就清楚了，就是一个节点，所以\n1 2 3 4 5 6 typedef struct node { int data; struct node *next; }Node; typedef struct Node * ListLink;//定义LinkList 只含一个指针域叫单链表，还有静态链表，双向链表，循环链表 通常用一个头指针指向链表，并且对与单链表，方便操作会设置头结点，头结点没有数据\n单链表 读取操作 算法思路：\n声明一个指针p，指向第一个节点，初始化j从1开始 当j\u0026lt;i时，遍历链表，不断更新p的指向 循环条件：\n若到链表末尾，p为空，则节点不存在 否则查找成功 实现：O(n)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int GetElem(LInkList L,int i,int *e) { LinkList p=L; int j; while (p\u0026amp;\u0026amp;j\u0026lt;i) { p=p-\u0026gt;next; } if (j=i) { *e=p-\u0026gt;data; } return ok; } 插入和删除操作 插入和删除:改变指针域指向就行，需要malloc和free函数\n插入第i个节点算法思路：\n声明指针p指向头结点，初始化j 当j\u0026lt;i时，就遍历链表，p指向下一个节点，j累加 若p在链表末尾指向空，则未查找到相应节点 否则查找到相应的节点，生成一个空节点 将数据e赋给其数据域 链接前驱结点与后继节点，标准插入语句：s-\u0026gt;next=p-\u0026gt;next,p-\u0026gt;next=s; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void LinkInsert(LinkList *L,int e,int i )//对于形参采用的是LinkList *这是便于头插法的插入，因为头指针会发生改变 { int j=1; LinkList p,s; p=*L; //这就是头结点，把\u0026amp;head传入，解后就是head节点 while (j\u0026lt;i\u0026amp;\u0026amp;p) //用while循环更好，因为for循环不能够判断p是否为空，如果i过大，单一的j\u0026lt;i就会一直循环直到j\u0026gt;i， 造成时间复杂度 { p=p-\u0026gt;next; //有了头结点p就指向了第i-1个节点 j++; } if (!p||j\u0026gt;i)//j\u0026gt;i指i可能为负数 { return error; } s=(LinkList)malloc(sizeof(Node)); s-\u0026gt;data=e; s-\u0026gt;next=p-\u0026gt;next;//这里前面已将判定了p!=NULL,所以可以对p进行操作 p-next=s; return ok; } 删除节点算法：\n声明指针p，初始化j j\u0026lt;i就循环，p更新，j累加 当p指向链表末尾为空，表示没有查找到相应的节点 否则，就删除节点，即p-next为待删除的节点，将p-\u0026gt;next=p-\u0026gt;next-\u0026gt;next 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void LinkDelete(LinkList *L,int i) { LinkList p=*L; int j; LinkList q; while ((p-\u0026gt;next)\u0026amp;\u0026amp;j\u0026lt;i) { p=p-\u0026gt;next; j++ } if ((p-\u0026gt;next)||j\u0026gt;i) { return error; } q=p-\u0026gt;next; } 这里应用了p-next而不是p，效果是一样的，正确退出循环时，p仍指向i-1个节点，不同的于p的是，对于没找到节点到末尾的情况，p-next为NULL，则p指向最后一个节点，后续还能够对该节点操作，但p=NULL，后续就不能对该节点操作\n单链表的整表创建 不同于声明数组，单链表的创建时一个空表逐渐插入各个节点的动态过程 创建算法：\n声明一个指针，计数器变量i 创建一个头结点，并使其指针域为NULL即带有头结点的空链表 循环： 生成一新节点赋给p 给p的指针域和数据域赋值 将p链接到上一节点 头插法 将节点插入在链表的头部 代买实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void CreatLinkList(LinkList *L,int n) { LinkList p; int i; srand(time(0)); *L=(LinkList)malloc(sizeof(Node)); (*L)-\u0026gt;next=NULL; p=(LinkList)malloc(sizeof(Node)); for (int i=1;i\u0026lt;=n;i++) { p=(LinkList)malloc(sizeof(Node)); p-\u0026gt;data=rand()%100+1; p-\u0026gt;next=(*L)-\u0026gt;next;//头结点后第一个元素更新 (*L)-\u0026gt;next=p; } } 尾插法 将节点插入尾部(常用)\n1 2 3 4 5 6 7 8 9 10 11 12 *L=(LinkList)malloc(sizeof(Node)); (*L)-next=NULL; LinkList p,q; q=*L; for (int i=1;i\u0026lt;=n;i++) { p=(Node *)malloc(sizeof(Node)); p-\u0026gt;data=rand()%100+1; q-\u0026gt;next=p; p-\u0026gt;next=NULL; q=p; } 单链表的整表删除 就是将每个节点的内存释放\n1 2 3 4 5 6 7 8 9 10 11 void LinkListDelete(LinkList *L) { LinkList current,nextnode; current=*L; while (current) { nextnode=current-\u0026gt;next; free(current); current=nextnode; } } 对比单链表结构与顺序存储结构 若线性表需要频繁查找，很少进行插入删除，宜采用顺序存储 若线性表中元素变化较大，并且元素个数不怎么确定是就用链式结构\n双向链表 弥补了单行链表中一个节点只能访问他之后的节点的缺点 实现方式：指针域增加两个，一个指向后驱节点，一个指向前驱结点 与单链表的差异：除了插入与删除元素，其他操作没有太大区别\n1 2 3 4 5 6 typedef struct node { int data; struct node *pre; struct node *next; }Node; 双向链表的插入与删除 改变两个指针\n1 2 3 4 5 //假设将e插入p和p-\u0026gt;next节点之间，有四步，顺序很重要,就是先搞定e的前驱指向和后继指向，再确定其他节点指向他 s-\u0026gt;next=p-\u0026gt;next; s-\u0026gt;pre=p; p-\u0026gt;next=s; s-\u0026gt;next-\u0026gt;pre=s; 删除\n1 2 3 4 //删除p节点,将p的前驱结点和后继节点连接起来就行 p-\u0026gt;pre-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next-\u0026gt;pre=p-\u0026gt;pre; free(p); 循环链表 作用：希望能从一个节点出发访问全部元素\n单链表循环 就是将末尾指针指向头结点而非NULL； 与单链表的主要差异：就是循环条件改变，原来是p-\u0026gt;next=NULL,现在是p-\u0026gt;next等于头结点则循环结束\n但此时对于末尾节点的访问仍为O(n),怎么能变为O(1),就是将头指针改为尾指针\n这样指针头指针就指向第一个结点，然后next就是指向下一个节点即头结点 改为尾指针还能够将两个循环链表连接起来合成一个表：\n只需要第一个链表的末尾节点不在指向头结点而指向第二个链表的第一个节点 将第二个链表的最后一个节点指向第一个链表的头结点 释放第二个链表的头结点 线性表总结 线性表按存储结构划分为顺序和链式结构，前者适用于多读取，少插入，后者适用于数据量不定，插入多 第四章 栈与队列 定义 一种特殊的线性表，只能在末尾进行插入和删除的线性表，类比手枪上子弹打出去的过程，现压的后打，后压的先打 队列是只允许在一端进行插入，在另一端进行删除的线性表\n栈 对于栈，我们把能够进行操作的一段称为栈顶，另一端为栈底，插入与删除为压栈和出栈 压栈和出栈的变化形式并不是唯一的 栈的抽象数据类型见源码\n栈的顺序存储结构及实现 顺序结构也就是数组，不同的是，我们要用一个变量来当做栈顶指针来指向栈顶，从而进行操作\n1 2 3 4 5 6 //栈的定义 typedef struct { int data[MAXSIZE];//将栈和一个int型数据表示栈顶元素的下标，抽象成一个数据类型 int top;//表示栈顶指针，指的是下标 }SqStake 栈的push(压栈)\n1 2 3 4 5 6 7 8 9 void Push(SqStake *s,int e) { if (s-\u0026gt;top+1=MAXSIZE) { return error; } s-\u0026gt;top++; s-\u0026gt;data[top+1]=e; } 栈的pop(出栈)\n1 2 3 4 5 6 7 8 void Pop(SqStake *s) { if (s-\u0026gt;top==-1) { return error; } s-\u0026gt;top--; } 两栈共用存储空间 将两个栈压入一个数组中，这样可以避免一个栈容量不够的同时，另一个栈容量太大的情况\n实现：\n就是将一个数组的尾部作为另一个栈的栈底，另一个栈正常在头部 此时有两个top(因为有两个栈)，什么时候栈满：就是top1和top2相差1的时候 定义\n1 2 3 4 5 6 typedef { int data[]; int top1; int top2; } 对与插入删除操作，我们还要分清是对栈1操作还是栈2,就用一个新变量stacknumber来表示对哪个栈操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void Push(Stack *s,int e,int stacknumber) { if(s-\u0026gt;top1-s-\u0026gt;top2==1) { return error; } else { if(stacknumber==1) { s-\u0026gt;top1++; s-\u0026gt;data[top1]=e; } if (stacknumber==2) { s-\u0026gt;top2++; s-\u0026gt;data[top2]=e; } } } 对于删除就不需要考虑容量，只需判断stacknumber即可\n栈的链式存储结构及实现 链表的头指针和栈顶指针可以合二为一，这样就要使用头插法来更新栈 结构代码：\n1 2 3 4 5 6 7 8 9 10 typedef struct StackNode { int data; struct StackNode *next; }StackNode,*LInkStackPtr//定义StackNode为结构标签，并定义LinkStackPtr为指向该结构的指针 typedef struct { LinkStackPtr top； int count; }LinkStack; 链栈的插入与删除\n对与要用LinkStack*s形参的解释：\n如果按值传递（即函数参数为 LinkStack S ，而不是 LinkStack *S ），函数内部对 S 的操作是对传入实参的副本进行的。\n无法修改原链栈：函数内修改 S 的 top 指针等成员变量，只是改变了这个副本的值，函数结束后，副本被销毁，原链栈的 top 等属性并不会发生改变。例如在入栈操作中，即使在函数内调整了副本的 top 指针指向新节点，但原链栈的 top 还是指向原来位置，新元素并没有真正入栈。 失去信息同步：对于记录元素个数的 count 成员也是同理，函数内修改副本的 count ，原链栈的 count 不会变化，导致链栈实际元素数量和记录数量不一致，破坏了链栈数据结构的完整性和准确性 。所以按值传递不能实现对原链栈的有效操作。 1 2 3 4 5 6 7 8 9 //push操作 void Push(LinkStack *s,int e) { StackNode *p=(StackNode *)malloc(sizeof(StackNode)); p-\u0026gt;data=e; p-\u0026gt;next=s-\u0026gt;top; s-\u0026gt;top=p; s-\u0026gt;count++; } 1 2 3 4 5 6 7 8 9 10 11 12 //pop操作 void pop(LinkStack *s) { if (StackEmpty(*s))//如果是空表，其原码都在D盘大话数据结构中 { return error; } StackNode*p=s-\u0026gt;top; s-\u0026gt;top=s-\u0026gt;top-\u0026gt;next; free(p); s-\u0026gt;count--; } 栈的应用 1.递归 存储某些数据，并在后面又以存储的逆序恢复这些数据，符合栈的先进后出，后进先出的特点\n简单说就是在前进的过程中(递归调用的过程)，函数的局部变量，参数值以及返回地址都被压入栈中，在退回阶段，位于栈顶的局部变量，参数值，及返回地址被弹出，用于返回调用代码的其余部分\n2. 四则运算表达式 计算机对与四则运算就是一个压栈出栈的过程，首先是将四则运算转化为后缀表达式，再将后缀表达式压入栈中\n转化规则：\n从左到右遍历表达式中的数字和符号，若是数字就输出，若是符号，就判断与栈顶符号的优先级，是右括号或者优先级不高于栈顶符号(乘除优先加减),就依次弹出栈顶符号并输出，并将当前符号进栈，一直到最终输出后缀表达式为止\n队列 定义 类比排队办业务\n队列是一种先进先出的线性表，简称FIFO，他只允许一端插入，一端删除，允许插入的一端是队尾，允许删除的一端是队头 队列的抽象数据类型见源码\n队列的顺序存储结构及实现 与栈类比，队列同样有顺序存储结构和链式存储结构\n对与顺序存储结构，即数组，为了弥补在头部元素出走，而移动后面全部元素的情况(O(n)),我们引入了两个类似指针的变量，来指向队头和队尾的下一个元素，这是为了当front=tail时，队列为空，而不是只剩下一个元素\n但同时又引出了新的问题：假溢出（看书）\n这样为了充分利用空间，就要用到循环队列，即tail不在指向数组之外，而是指向头部\n那么在循环链表又会出现一种情况就是，front=tail同样为队列满，如何区分队列空与满呢？\n用标志变量\n设定队列为满新的规则：\n当队列中只有一个空元素时，队列是满的\n如何判断队列只有一个空元素？\n假设数组最大长度为Max，公式：(tail+1)%Max==front,这就是列表满了\n通用的计算队列长度公式：Length=(tail-front+Max)%Max\n基于以上分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 //队列结构 typedef struct { int data[]; int front; int tail; }SqQueue; //队列初始化 void InitQueue(SqQueue *Q) { s-\u0026gt;front=0; s-\u0026gt;tail=0; } //返回队列的长度 int QueueLength(SqQueue *s) { return (s-\u0026gt;tail-s-\u0026gt;fornt+Max)%Max; } //循环队列的入队列操作 void QueueInsert(SqQueue *s,int e) { if ((s-\u0026gt;tail+1+Max)%Max==fornt) { return error; } else { s-\u0026gt;data[tail]=e; s-\u0026gt;tail=(tail+1+Max)%Max; } } //删除 void QueueDelete(SqQueue *s) { if (s-\u0026gt;tail==s-\u0026gt;fornt) { return errorr; } else { s-\u0026gt;front=(s-\u0026gt;fornt+1+Max)%Max; } } 总结：对与顺序存储的队列，单是单队列，会面临存储效率不高，从而引入循环队列，但是循环队列又要考虑数据溢出的问题，所以还是不够全面\n队列的链式结构及实现 队列的链式结构，就是一个链表加上指向两头的指针，通常对于链表对象结构的定义，是先定义节点(方便进行节点的插入)，在定义队列的结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 //队列的链式定义 typedef struct node { int data; struct node *next; }Node,* Qnodeptr; typedef struct { Qnodeptr fornt; Qnodeptr tail; }LinkQueue; //入队列 void LinkQueueIn(LinkQueue *q,int e) { Quenodeptr s =(Quenodeptr )malloc(sizeof(Node)); if (!s) { return error; } else { s-\u0026gt;data=e; s-\u0026gt;next=NULL; q-\u0026gt;tail-\u0026gt;next=s; q-\u0026gt;tail=s; } } //出队列 void LinkQueueDe(LinkQueue *q) { LinkQueue p; p=q-\u0026gt;front-\u0026gt;next; if (q-\u0026gt;front=q-\u0026gt;tail) { return error; } else { q-\u0026gt;front-\u0026gt;next=p-\u0026gt;next; //此时还要判断如果队列只有一个元素，就要变成空队列。 if (q-\u0026gt;tail==p) { q-\u0026gt;tail=q-\u0026gt;front; } free(p); } } 总结 栈与队列都是特殊的线性表，前者后进先出，只在栈顶操作；后者只能前删后插；他们都有顺序存储结构，也都存在一些缺点；\n例如\n栈的顺序存储：因为易造成溢出或空间的浪费，所以有了两个栈共享一个数组 队列的顺序存储同样有数据溢出与浪费，所以有了循环队列\n第五章 串 定义 串就是由另个或多个字母组成的有限序列，又称字符串\n串的抽象数据类型\n我们常常就数组的第一个元素设置为字符串的长度，就是第一个元素并不存储字符串，从下表为1的位置存储第一个字符串\nIndex的操作实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //若字符串T不为空，若主字符串第pos个字符后存在与T相同的字符串 //那么就返回第一个字符串的首字符的位置，否则返回0 //有运用到string函数 int Index(string S,string T,int pos) { int m,n; m=strlength(S); n=strlength(T); int i=pos; while (i\u0026lt;=m-n+1)//公式，就是第i组元素的最后一个元素要小于字符串长度，即i+n-1\u0026lt;=m { SunString(su,S,i,m); if (strcompare(sub,T)!=0) { i++; } else { return i; } } return 0; } 一些字符串的模式匹配算法 普通算法 前面我们用了串的其他操作实现了index操作，现在我们用基础的数组来解决此问题 前提数组首元素存的是字符串长度，不是字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int Index(String S,Strint T,int pos) { int i=pos; int j=1; while (i\u0026lt;=S[0]\u0026amp;\u0026amp;j\u0026lt;=T[0]) { if (S[i]==T[j]) { i++; j++; } else { i=i-j+2; j=1; } } if (j\u0026gt;T[0]) { return i-T[0]; } else { return 0; } } KMP模式匹配算法 普通算法时间上复杂度上比较繁琐，例如如果我们已知了前三个元素都与T的第一个元素不匹配，则正常依次比较T的第一个元素与S的1,2,3元素是浪费的\n例如上图，我们一直在T中，abcdex，其中a与后面的元素均不相同，则已经判断了S中前5个元素与T相同则在第六个元素比对不同时，就没必要在将a与S中的bcde比较，因为已知bcde与T匹配成功，而T中a又与后面的bcde不同，自然与S中的第2~4元素不同，所以图二到图五都可以省略\n当然此处的前提是T中第一个元素与去后面的都不相同，部分相同后面再说\n对与部分相同，我们采用KMP算法\nKMP算法：利用一个next数组来实现，即存储的最大真前后缀长度\nNext数组实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //假设next数组首元素正常存储，串T首元素正常存储 void GetNext(string T,char *next) { int m=strlen(T); next[0]=0; for (int i=1;i\u0026lt;m;;i++) { k=next[i-1]; while (k\u0026amp;\u0026amp;T[i]!=T[k]) { k=next[k-1]; } if (T[i]=T[k]) { next[i]=k+1;//算的是当前位置的next值 } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //假设next数组首元素不存，下标为1对应串T中下标为1的元素，即串T下标对应字符位置 void GetNext(string T,char *next) { int m=strlen(T); next[1]=0; int i=0; while (i\u0026lt;m) { if (k==0||T[i]==T[k]) { i++; k++; next[i]=k;//算的是第i加一后的元素的next值 } if(T[i]!=T[k]) { k=next[k]; } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 //正常写数组\u0026amp;\u0026amp;依次比较主串和模版串 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define Max_size 100 void s_gets(char *str); void get_next(char *template_string,int *next); int main() { //模版串和主串 char template_string[Max_size]; char main_string[Max_size]; printf(\u0026#34;Input the template_string:\u0026#34;); s_gets(template_string); printf(\u0026#34;Input the main_string:\u0026#34;); s_gets(main_string); //计算长度，不包括\\0 int temp_length,main_length; temp_length=strlen(template_string); main_length=strlen(main_string); int i,j; int k=0; //计算模版串的next int next[temp_length]; get_next(template_string,next); //依次比较模版串和主串的元素 while (j\u0026lt;temp_length\u0026amp;\u0026amp;i\u0026lt;main_length) { if (j==0||template_string[j]==main_string[i]) { i++; j++; } //这种next数组的计算包括自身，那么当不相同时，就要看前一个元素的next，来进行移动 else { j=next[j-1]; } } //循环完后，根据j的值判断是否找到 if (j==temp_length) { printf(\u0026#34;Find Sucessful!\\n下标是%d\u0026#34;,i-temp_length); } return 0; } void s_gets(char *str) { int n; printf(\u0026#34;Input the number of string:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); char *arr; char *find; getchar(); arr=fgets(str,n+1,stdin); if (arr) { find=strchr(str,\u0026#39;\\n\u0026#39;); if (find) { *find=\u0026#39;\\0\u0026#39;; } else { while (getchar()!=\u0026#39;\\n\u0026#39;) continue; } } } void get_next(char *template_string,int *next) { int m=strlen(template_string); int i; next[0]=0; for (i=1;i\u0026lt;m;i++) { int k=next[i-1]; while (k!=0\u0026amp;\u0026amp;template_string[i]!=template_string[k]) { k=next[k-1]; } if (template_string[i]==template_string[k]) { next[i]=k+1; } else { next[i]=0; } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 //正常写数组\u0026amp;\u0026amp;用链接的方式判断(思路有技巧) #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define N 100 void s_gets(char *str); int main() { char template[N];//模版串 char main_string[N];//主串 //读取 printf(\u0026#34;input template\\n\u0026#34;); s_gets(template); int n=strlen(template); printf(\u0026#34;input mainstring\\n\u0026#34;); s_gets(main_string); //将主串连到模版串后面 char *cat_string=strcat(template,main_string); //得到连接后的串的长度 int m=strlen(cat_string); //计算连接后的next数组 int next[m]; next[0]=0; for(int i=1;i\u0026lt;m;i++) { int k=next[i-1];//计算当前i的next数值 //当k不为0时(因为后面套k-1\u0026gt;0)并且!=(要更新k值),注意是!=k而不是k-1 while (k!=0\u0026amp;\u0026amp;cat_string[i]!=cat_string[k]) { k=next[k-1];//这个是k-1，不是k } if (cat_string[i]==cat_string[k]) { next[i]=k+1;//next[里面是i] } else { next[i]=0; } if (next[i]==n)//这个n是模版串的长度 { printf(\u0026#34;find it !\\n下标是%d\u0026#34;,i-n+1);//下标是在主串中的下标 } } return 0; } void s_gets(char *str) { int n; printf(\u0026#34;Input the number of string:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); char *arr; char *find; getchar(); //想要读取n个字符，那么fgets要用n+1作为参数，因为若为n，则fget最多读取n-1个字符，要留一个给\\0 arr=fgets(str,n+1,stdin); if (arr) { find=strchr(str,\u0026#39;\\n\u0026#39;); if (find) { *find=\u0026#39;\\0\u0026#39;; } else { while (getchar()!=\u0026#39;\\n\u0026#39;) continue; } } } 第六章 树 定义 就是有n个节点的有限集，其中有且仅有一个节点称为根节点，另外的节点又可以组成m个互不相交的的有限集，每个有限集称为子树\n一些名词：根节点，叶节点（就是没有孩子），节点的度（就是有孩子）就是孩子个数，深度就是几层楼\n树的存储结构(表示方法) 双亲表示法 1 2 3 4 5 6 7 8 9 10 11 typedef struct ParentNode { int data; int parent; }PT; typedef struct PTree { PT tree[]； } //用数组，每个元素有数据域，和指针域，指针域指向父母 //这种方法好找父母，但是兄弟不好找，当然可以通过增加指针域个数（指针数组）来指向多个兄弟，但是容易造成空间浪费 孩子表示法 依据每个父母的左孩子是唯一的，所以我们将每个节点放入数组中，节点·包含数据域和一个单链表(用来描述该节点从左到右的孩子)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //用来表示单链表的指向 typedef struct ChNode { int child（孩子的下标） struct ChNode *next; }ChNode; //用于表头的·表示 typedef struct { int data; ChNode firstchild; }CT; typedef struct ChTree { CT node[节点个数]； } 孩子兄弟表示法 依据：每个左孩子的兄弟时唯一的，要么没有\n1 2 3 4 5 6 7 typedef struct BroNode { int data; struct BroNode *child; struct BrotherNode *brother; }Bro; //用一个节点就可以发散到整棵树 二叉树 特点\n每个节点只有两棵树 左右节点不能换 只有一个节点时，也要区分是左还是右 分类：\n斜树：只有左节点或右节点 满二叉树：每一层都是满的 完全二叉树：每个节点顺序与满二叉树相同，即最后一层之前的每一层都是满的，对与最后一层，节点必须按顺序出现，不能一个节点有右无左 性质：\n第i层最多有2^(i-1)个节点 深度为k的是树最多有2^k-1个节点 对与任意一个二叉树，它的终端节点（n0）和度为2的节点（n2）的关系：n0=n2+1； 有n个节点的完全二叉树，它的层数为[log下2上（n+1）]+1 对与n个节点的完全二叉树，（深度为[log下2上（n+1）]+1]，的节点按层序编号，对与任意几点有 如果i=1，则·节点是根几点，无双亲；如果i\u0026gt;1，则双亲是[i/2] 如果2i\u0026gt;n,则节点无左孩子（即节点i为叶子节点），否则其左孩子时节点2i； 如果2i+1\u0026gt;n则节点无右孩子，否则右孩子是2i+1 二叉树的遍历 定义二叉树结构\n1 2 3 4 5 6 typedef struct TreeNode { int data; Struct TreeNode *l-child; Struct TreeNode *r-child; } 方法：\n前序遍历 中序遍历 后序遍历 前序遍历 每到一个节点就访问它的值，按照从上至下，从左到右的顺序遍历\n1 2 3 4 5 6 void Preorder(Tree T) { printf(\u0026#34;%d\u0026#34;,T-\u0026gt;data); Preorder(T-\u0026gt;l-child); Preorcer(T-\u0026gt;r-child); } 中序遍历 同样由根节点开始（但不访问只是借助他来访问左叶节点），即从左叶节点开始打印\n即对每个节点，先打印它的左孩子，再打印他自己，最后打印右孩子\n1 2 3 4 5 6 void Miorder(Tree T) { Miorder(T-\u0026gt;l-child); printf(\u0026#34;%d\u0026#34;,T-\u0026gt;data); Miorder(T-\u0026gt;r-child); } 后序遍历 根节点是最后打印的，先遍历左树，再右树最后根节点\n即对每个节点先打印它的孩子，最后打印自己\n1 2 3 4 5 6 void Laorder(Tree T) { Laorder (T-\u0026gt;l-child); Laorder (T-\u0026gt;r-child);; printf(\u0026#34;%d\u0026#34;,T-\u0026gt;data); } ","date":"2025-05-12T19:48:22+08:00","permalink":"https://qjy517.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/","title":"数据结构笔记"},{"content":"markdown语法练习 关于文本的操作 换行 这是第一段文字，首先是文本换行也就是软换行可以用shift键加上回车 这就是文本换行\n段落换行就是一次回车\n斜体 收尾加上星号表示斜体\n加粗 收尾加上两个星号表示加粗\n既要斜体也要加粗 就是三个星号\n删除线 文本首尾加两个波浪线\n分割线 在两个文本之间加上三个星号\n用于两个段落之间，实例：\n段落一\n段落二\n列表 无序列表 第一排\n在列表内换行，用文本内换行\n第二排\n第三排\n两个回车会退出列表\n有序列表 同习惯一样，数字加小数点加空格\n第一排 第二排 列表平行 只能在两个列表之间用一个完整的行分开才行，或者直接按上下左右的有方向键\n此时按右方向键就时新的一行 列表嵌套 只需遵循对应的语法就行\n列表项目打钩 勾选框：在原有的星号空格后面打上中括号，中间有一个空格，后面再加上一个空格 打钩：将中括号里面的空格替换为x 实例：\n这是勾选框\n这是勾选之后的样式\n代码块 常用三个`生成一个代码块\n显示代码语言：在三个`后面加上语言名称如c，Java\n行内代码块：首尾一个`就行\n实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void hanoi(int n,char F,char E,char T); void move(char F,char E); int main() { int n; printf(\u0026#34;Input the number of disks:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); printf(\u0026#34;Steps of moving %d disks from A to C by means of B:\\n\u0026#34;,n); hanoi(n,\u0026#39;A\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;B\u0026#39;); return 0; } void hanoi(int n,char F,char E,char T) { if (n==1) { move(F,E); } //后面三个语句要用{}括起来，因为不括起来，在基准问题即n=1，执行完之后 //不会返回到上一个主调函数，会继续运行hanoi //还要注意，这里递归调用hanoi的参数应为主调函数的F,E,T,不是\u0026#39;A\u0026#39;\u0026#39;B\u0026#39;\u0026#39;C\u0026#39; else { hanoi(n-1,F,T,E); move(F,E); hanoi(n-1,T,E,F); } } void move(char F,char E) { printf(\u0026#34;%c-\u0026gt;%c\\n\u0026#34;,F,E); } 行内代码块 printf\n声明一个引用 一个\u0026gt;加空格在加上引用的文本，同样的换行条件，同样可以在引用文本框内嵌套 列表，代码等块，只需对应的语法，还可以嵌套本身，退出仍是两个回车，软换行还是shift键加回车\n高尔基曾说过：书籍是人类进步的阶梯\n引用嵌套 这是汉诺塔代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void hanoi(int n,char F,char E,char T); void move(char F,char E); int main() { int n; printf(\u0026#34;Input the number of disks:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); printf(\u0026#34;Steps of moving %d disks from A to C by means of B:\\n\u0026#34;,n); hanoi(n,\u0026#39;A\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;B\u0026#39;); return 0; } void hanoi(int n,char F,char E,char T) { if (n==1) { move(F,E); } else { hanoi(n-1,F,T,E); move(F,E); hanoi(n-1,T,E,F); } } void move(char F,char E) { printf(\u0026#34;%c-\u0026gt;%c\\n\u0026#34;,F,E); } 超链接 中括号里面写内容，空格再加上小括号里面写网址 进阶：用变量名表示网址：段落换行后，写出变量对应的地址,注意冒号后空一格\n这是 百度 的链接，如果多次使用同一个链接，可以用变量名表示网址\n实例：这是百度,这也是百度。\n角注 [^数字]，然后同上定义角注内容\n实例：\n百度1\n图片插入 一个![可写可不写]再加上一个(图片地址，可网络可本地)，但大小不可调，有个网址可以配置图床，以及搜一下typora怎么配置自动上传\n表格插入 |表示表格边框 表格内容对区方式：用:控制，两边都加上表示居中，只加一边表示偏向一侧\n实例：\n姓名 年龄 性别 小红 14 女 我是角注\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-05-11T16:24:58+08:00","permalink":"https://qjy517.github.io/p/markdown/","title":"Markdown"},{"content":"","date":"2025-05-08T23:34:11+08:00","permalink":"https://qjy517.github.io/p/test/","title":"Test"},{"content":"图床搭建 选用阿里云来搭建图床 注意：\nOSS是这么算收费的。9元一年的包是给存储费用的，和流量费用没关系 oss收费：存储的费用 + 外网流出的费用 + 上传免费，而购买oss资源包（40G/9元/年）只是对存储费用的抵扣，还需要再付费外网流程费用 我选用的就是9元的存储包，外网浏览额外计费，只是有了每年40G的云存储，但个人博客浏览量不大，可以忽略，注意这是支付宝每年自动扣费的，可退订，且扣费是在阿里云账户不是支付宝账户 有关picgo配置 在picgo设置中，可以开启自定义文件名，有关的可以网上搜索\n关于typora的图像设置 如图如果在插入图片这三个选项栏，第一个必须，重点是第二个不勾选代表则是对已经上传到阿里云的图片，不会再次上传，会将重复的图片链接显示红色\n实例：像正常上传一个图片 再次上传会变红： https://bucket-qjy.oss-cn-qingdao.aliyuncs.com/picture/202505132233881.png\n但如果开启第二个，则不会变红，会重复上传这个照片到阿里云\n参考的部署链接 链接1\n[链接2](搭建图床存储个人文件_typora gopic-CSDN博客)\n","date":"2025-05-08T16:56:18+08:00","permalink":"https://qjy517.github.io/p/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","title":"图床搭建的注意事项"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://qjy517.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://qjy517.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://qjy517.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://qjy517.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://qjy517.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://qjy517.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://qjy517.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://qjy517.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://qjy517.github.io/p/emoji-support/","title":"Emoji Support"}]